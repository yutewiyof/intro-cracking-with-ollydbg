# Цикл туториалов Рикардо Нарвахи "Введение в крэкинг с помощью OllyDbg"

Данный документ призван сделать курс Рикардо мощным справочным пособием как для начинающего, так и для тех, кто уже владеет искусством крэкинга. Для облегчения поиска я постарался сделать его как можно более подробным, а также присоединил материал, опубликованный в списке конкурсов CracksLatinoS и относящийся к некоторым темам курса. Я посчитал его важным, несмотря на то, что он не входит в состав туториалов Рикардо. См., например:

[**Глава 44**](44.md)
**Распаковка ACProtect 1.09g.f со всеми функциями защиты (3-я часть)**
![](img/0/1.png) Восстановление украденных байтов и OEP
![](img/0/1.png) Борьба с антидампом
**Как сделать вставку, если секция, которую нужно создать, занята (дополнение к главе 44)** *[Сноска 1](#footnote1)*


*\[Лазурно-синим выделена ссылка на статью.\]*
Желтым выделена ссылка на комментарий, находящийся в этом же документе. Я оформил дополнительные материалы в виде комментариев, чтобы не присоединять файлы.

1.  [Глава 1](ch-01.md)
    * **Части главного окна OllyDbg**
    * ![](img/0/1.png) Дизассемблер (листинг)
    * ![](img/0/1.png) Область регистров
    * ![](img/0/1.png) Дамп
    * ![](img/0/1.png) Стек
    * **Остальные окна OllyDbg**
    * ![](img/0/2.png) Окно Log
    * ![](img/0/3.png) Окно Executables
    * ![](img/0/4.png) Окно Memory
    * ![](img/0/5.png) Окно Threads
    * ![](img/0/6.png) Окно Windows
    * ![](img/0/7.png) Окно Handles
    * ![](img/0/8.png) Окно CPU
    * ![](img/0/9.png) Окно Patches
    * ![](img/0/10.png) Окно Call Stack
    * ![](img/0/11.png) Окно BreakPoints
    * ![](img/0/12.png) Окно References
    * ![](img/0/13.png) Окно Run Trace
    * **Установка OllyDbg в качестве JIT (Just-In-Time Debugger)**
    * **Подключение плагинов в OllyDbg**
    * **Горячие клавиши**
    * ![](img/0/1.png) F2
    * ![](img/0/1.png) F7
    * ![](img/0/1.png) F8
    * ![](img/0/1.png) F9
    * ![](img/0/1.png) F12

2.  [Глава 2](ch-02.md)
    * **Системы счисления**
    * ![](img/0/1.png) Двоичная
    * ![](img/0/1.png) Десятичная
    * ![](img/0/1.png) Шестнадцатеричная
    * ![](img/0/1.png) Положительные и отрицательные числа в шестнадцатеричной системе счисления
    * **ASCII-символы
    * Что такое стек (куча)?

3.  [Глава 3](ch-03.md)
    * Что такое регистры и для чего они нужны?
    * ![](img/0/1.png) Дробление регистров (EAX → АХ | AL)**
    * Как изменять значения регистров?
    * Что такое флаги?**
    * ![](img/0/1.png) Флаг O (Overflow, переполнение)
    * ![](img/0/1.png) Флаг A (Auxiliar, дополнительный флаг переноса)
    * ![](img/0/1.png) Флаг P (Parity, четность)
    * ![](img/0/1.png) Флаг Z (Zero, нуль)
    * ![](img/0/1.png) Флаг S (Sign, знак)
    * ![](img/0/1.png) Флаг C (Carry, перенос)
    * ![](img/0/1.png) Флаги T, D и I

4.  [Глава 4](ch-04.md)
    * **Ассемблерные инструкции**
    * ![](img/0/1.png) NOP
    * ![](img/0/1.png) PUSH
    * ![](img/0/1.png) POP
    * ![](img/0/1.png) PUSHAD
    * ![](img/0/1.png) POPAD
    * ![](img/0/1.png) PUSHA
    * ![](img/0/1.png) POPA
    * ![](img/0/1.png) MOV
    * ![](img/0/1.png) MOVSX
    * ![](img/0/1.png) MOVZX
    * ![](img/0/1.png) LEA
    * ![](img/0/1.png) XCHG


5.  [Глава 5](ch-05.md)
    * **Математические инструкции**
    * ![](img/0/1.png) INC
    * ![](img/0/1.png) DEC
    * ![](img/0/1.png) ADD
    * ![](img/0/1.png) ADC
    * ![](img/0/1.png) SUB
    * ![](img/0/1.png) SBB
    * ![](img/0/1.png) MUL
    * ![](img/0/1.png) IMUL
    * ![](img/0/1.png) DIV
    * ![](img/0/1.png) XADD
    * ![](img/0/1.png) NEG
    * **Логические инструкции**
    * ![](img/0/1.png) AND
    * ![](img/0/1.png) OR
    * ![](img/0/1.png) XOR
    * ![](img/0/1.png) NOT

6.  [Глава 6](ch-06.md)
    * **Инструкции сравнения и условных переходов**
    * ![](img/0/1.png) CMP
    * ![](img/0/1.png) TEST
    * **Инструкции переходов**
    * ![](img/0/1.png) JMP
    * ![](img/0/1.png) JE ИЛИ JZ
    * ![](img/0/1.png) JNE ИЛИ JNZ
    * ![](img/0/1.png) JS
    * ![](img/0/1.png) JNS
    * ![](img/0/1.png) JP ИЛИ JPE
    * ![](img/0/1.png) JNP ИЛИ JNPE
    * ![](img/0/1.png) JO
    * ![](img/0/1.png) JNO
    * ![](img/0/1.png) JB
    * ![](img/0/1.png) JNB
    * ![](img/0/1.png) JBE
    * ![](img/0/1.png) JNBE
    * ![](img/0/1.png) JL
    * ![](img/0/1.png) JA JG JAE JGE

7.  [Глава 7](ch-07.md)
    * **Инструкции ассемблера:**
    * ![](img/0/1.png) CALL
    * ![](img/0/1.png) RET

8.  [Глава 8](ch-08.md)
    * **Инструкции циклов \***
    * ![](img/0/1.png) LOOP
    * ![](img/0/1.png) LOOPZ LOOPE
    * ![](img/0/1.png) LOOPNZ LOOPNE
    * **Строковые (цепочечные) инструкции**
    * ![](img/0/1.png) MOVS
    * ![](img/0/1.png) REP
    * ![](img/0/1.png) REPE REPZ
    * ![](img/0/1.png) LODS
    * ![](img/0/1.png) STOS
    * ![](img/0/1.png) CMPS
    * **Способы адресации**
    * ![](img/0/1.png) Прямая адресация
    * ![](img/0/1.png) Косвенная адресация
    * \* В этой главе рассматривается функционирование циклов.

9.  [Глава 9](ch-09.md)
    * **Базовые понятия**
    * ![](img/0/1.png) Entry Point (точка входа)
    * ![](img/0/1.png) DLL (динамическая библиотека)
    * ![](img/0/1.png) API-функция
    * **Как узнать список API-функций, использующихся в программе? (Search for -> Name (label) in current module (Ctrl+N))****
    * **Как используются API-функции?**

10.  [Глава 10](ch-10.md)
        * **Брейкпоинты**
        * ![](img/0/1.png) Обычные брейкпоинты (BP, BPX)
        * ![](img/0/1.png) Брейкпоинты на доступ к памяти (BPM, Memory Breakpoint)

11.  [Глава 11](ch-11.md)
        * **Брейкпоинты**
        * ![](img/0/1.png) Аппаратные брейкпоинты (HBP)
        * ![](img/0/1.png) Условные брейкпоинты (Conditional Breakpoint)
        * ![](img/0/1.png) Условные брейкпоинты с логированием (Conditional Log Breakpoint)

12.  [Глава 12](ch-12.md)
     * **Как пользоваться сообщениями Windows’а?**
     * ![](img/0/1.png) Брейкпоинты на сообщениях (BMSG)

13.  [Глава 13](13.md)
     * **Поиск серийных номеров**
     * ![](img/0/1.png) Жестко заданные (hardcoded) серийные номера
     * ![](img/0/1.png) API-функция GetDlgItemTextA

14.  [Глава 14](ch-14.md)
        * **Решение крэкми, упомянутого в предыдущей главе**
        * ![](img/0/1.png) API-функция lstrcmpA
        * ![](img/0/1.png) API-функция GetWindowTextA
        * **Другой крэкми с hardcoded-серийником**
        * ![](img/0/1.png) API-функция memset
        * ![](img/0/1.png) API-функция lstrlen

15.  [Глава 15](ch-15.md)
        * Решение крэкми, упомянутого в предыдущей главе (Splish)
        * Поиск серийника в упакованном крэкми (Sambo)
        * ![](img/0/1.png) Использование сообщений Windows’а

16.  [Глава 16](ch-16.md)
        * **Крякмисы с переменным серийным номером**
        * ![](img/0/1.png) Крэкми CrueHead’а
        * ![](img/0/1.png) Крэкми Splish, 2-я часть с вводом имени пользователя (name/serial)
        * ![](img/0/1.png) Инструкция CDQ
        * ![](img/0/1.png) Инструкция IDIV ESI

17.  [Глава 17](ch-17.md)
        * Решение крэкми, упомянутого в предыдущей главе (Mexcrk1)
        * Игра Canasta v5.0 (В данной программе кнопка OK для ввода серийника изначально неактивна.)

18.  [Глава 18](ch-18.md)
        * **Использование сообщений Windows’а для поиска серийника (WM\_KEYUP)**
        * ![](img/0/1.png) Крэкми Stzwei’я (crackme\_4stz)

19.  [Глава 19](ch-19.md)
        * **Обнаружение отладчика**
        * ![](img/0/1.png) API-функция IsDebuggerPresent
        * ![](img/0/1.png) Патч крэкми против обнаружения
        * ![](img/0/1.png) Расположение соответствующего байта
        * ![](img/0/1.png) Изменение флага во избежание обнаружения
        * ![](img/0/1.png) Сокрытие отладчика с помощью плагина (Hide Debugger 1.23f)

20.  [Глава 20](ch-20.md)
     * **Обнаружение OllyDbg по названию процесса**
     * ![](img/0/1.png) API-функция OpenProcess
     * ![](img/0/1.png) API-функция EnumProcessModules
     * ![](img/0/1.png) API-функция GetModuleBaseName
     * **Использование API-функции GetProcAddress**

21.  [Глава 21](ch-21.md)
     * Другие антиотладочные приемы
     * ![](img/0/1.png) API-функция CreateToolhelp32Snapshot
     * ![](img/0/1.png) API-функция Process32First
     * ![](img/0/1.png) API-функция Process32Next
     * ![](img/0/1.png) API-функция TerminateProcess
     * ![](img/0/1.png) API-функция FindWindow
     * ![](img/0/1.png) API-функция EnumWindows

22.  [Глава 22](ch-22.md)
     * **Антиотладка**
     * ![](img/0/1.png) Исключения, не обрабатываемые в OllyDbg (Unhandled  * Exceptions)
     * ![](img/0/1.png) API-функция SetUnhandledExceptionFilter
     * ![](img/0/1.png) API-функция ZwQueryInformationProcess
     * ![](img/0/1.png) API-функция UnhandledExceptionFilter
     * **Плагин HideOD**

23.  [Глава 23](ch-23.md)
     * **Завершение изучения методов антиотладки**
     * ![](img/0/1.png) Расположение байтов:
     * ![](img/0/1.png) NTGloblalFlag
     * ![](img/0/1.png) ProcessHeap
     * **API-функция OutputDebugString**

24.  [Глава 24](ch-24.md)
     * Решение крэкми, упомянутого в предыдущей главе (antisocial)
     * ![](img/0/1.png) С плагинами и без плагинов

25.  [Глава 25](ch-25.md)
     * **Обработка исключений**
     * ![](img/0/1.png) Понятие исключения
     * **Разновидности исключений**
     * ![](img/0/1.png) Нет доступа к памяти
     * ![](img/0/1.png) Деление на ноль
     * ![](img/0/1.png) Неверная инструкция; попытка запуска привилегированной инструкции
     * **Как изменить настройки доступа секций в Olly?**
     * Что происходит, когда генерируется исключение?
     * Что такое SEH?
     * Как устанавливается обработчик исключений?**

26.  [Глава 26](ch-26.md)
     * Версия Olly "Parcheado 5" (пропатченный Olly для поиска OEP’ов)
     * Взлом приложений, написанных на Visual Basic’е (VB)
     * Значение составляющих имени API-функции VB
     * Примеры API-функций
     * ![](img/0/1.png) Конвертация данных
     * ![](img/0/1.png) Перемещение данных
     * ![](img/0/1.png) Математические
     * ![](img/0/1.png) Вспомогательные
     * ![](img/0/1.png) Сравнения

27.  [Глава 27](ch-27.md)
     * **Как устроен екзешник, скомпилированный VB’ком?**
     * ![](img/0/1.png) Метод 4C

28.  [Глава 28](ch-28.md)
     * **На войне как на войне**
     * ![](img/0/1.png) Другой способ удаления наг-окон в VB**
     * ![](img/0/1.png) Вставка кода в DLL’ку VB

29.  [Глава 29](ch-29.md)
     * **P-Code (псевдокод)**
     * ![](img/0/1.png) Распознавание, изучение и взлом (API-функция MethCallEngine)
     * ![](img/0/1.png) Рассмотрение некоторых опкодов

30.  [Глава 30](ch-30.md)
     * **Завершение изучения программ на P-Code**
     * ![](img/0/1.png) Еще опкоды
     * ![](img/0/1.png) Решение крэкми, упомянутого в предыдущей главе

31.  [Глава 31](ch-31.md)
     * **Вводные сведения о распаковке**
     * ![](img/0/1.png) Для чего нужна упаковка программ?
     * ![](img/0/1.png) Что такое загрузчик и как он функционирует? (краткое объяснение)
     * ![](img/0/1.png) Понятие OEP
     * ![](img/0/1.png) Схема работы упакованной программы

32.  [Глава 32](ch-32.md)
     * **Классический способ распаковки**
     * **Методы нахождения OEP**
     * ![](img/0/1.png) Просмотр или поиск опкодов в листинге без запуска процедуры распаковки
     * ![](img/0/1.png) Использование встроенного в Olly поисковика OEP’ов
     * ![](img/0/1.png) Использование Olly Parcheado 5 (пропатченного Olly для поиска OEP’ов)
     * ![](img/0/1.png) Метод PUSHAD
     * ![](img/0/1.png) Для программ, написанных на VB (Native или P-Code)
     * ![](img/0/1.png) Метод исключений
     * ![](img/0/1.png) По API-функции, часто используемой распаковщиком
     * ![](img/0/1.png) Метод первой API-функции, вызываемой программой

33.  [Глава 33](ch-33.md)
     * **Что такое IAT?**
     * Использование LordPE снятия дампа
     * Что такое IT?
     * **Как система наполняет IAT?**

34.  [Глава 34](ch-34.md)
     * Распаковка вручную UPXа и восстановление IATа
     * ![](img/0/1.png) Использование PE Tools для снятия дампа
     * ![](img/0/1.png) Как восстановить IAT?

35.  [Глава 35](ch-35.md)
     * **Распаковка ASPack 2.12**
     * ![](img/0/1.png) Использование OllyDump для получения дампа
     * ![](img/0/1.png) Использование Import REConstructor’а для восстановления IATа

36.  [Глава 36](ch-36.md)
     * **Распаковка Crunch 5.0.0 (Bit-Arts)**
     * Распаковка tElock 0.98b1**
     * ![](img/0/1.png) Переадресовочные элементы IATа

37.  [Глава 37](ch-37.md)
     * **Способы восстановления переадресовочных элементов IATа**
     * ![](img/0/1.png) Метод восстановления вручную**
     * ![](img/0/1.png) Использование функции условного трассирования Olly
     * ![](img/0/1.png) Использование плагинов Import REConstructor’а
     * ![](img/0/1.png) Использование трассировщиков, встроенных в Import REConstructor
     * ![](img/0/1.png) Использование ключевых переходов JMP/CALL

38.  [Глава 38](ch-38.md)
     * **Распаковка Yoda’s Protector 1.3 (Yoda’s Crypter)**

39.  [Глава 39](ch-39.md)
     * Распаковка PELock 1.06.d (1-я часть)
     * Собственное логирование исключений
     * Начало темы об украденных байтах
     * ![](img/0/1.png) Как узнать, были ли украдены байты?
     * ![](img/0/1.png) Возвращение украденных байтов с помощью Binary copy / Binary paste
     * **Украденный код**

40.  [Глава 40](ch-40.md)
     * Баг обработки исключений в OllyDbg
     * Плагин OllyScript 0.92
     * Скрипт сокрытия HBP для PELock, tElock и пр.

41.  [Глава 41](ch-41.md)
     * Распаковка PELock 1.06.d (2-я часть)
     * Разновидности антидампа
     * ![](img/0/1.png) Борьба с антидампом, создающим секции во время распаковки
     * ![](img/0/1.png) Добавление в дамп секции, созданной во время распаковки
     * ![](img/0/1.png) Ссылка на метод, предложенный marciano

42.  [Глава 42](ch-42.md)
     * **Распаковка ACProtect 1.09g.f со всеми опциями защиты (1-я часть)**
     * ![](img/0/1.png) Рассмотрение отладочных регистров в структуре CONTEXT
     * ![](img/0/1.png) Поиск OEP с помощью скрипта, скрывающего аппаратные брейкпоинты
     * ![](img/0/1.png) Восстановление украденных байтов

43.  [Глава 43](ch-43.md)
     * **Распаковка ACProtect 1.09g.f со всеми опциями защиты (2-я часть)**
     * ![](img/0/1.png) Восстановление IATа с помощью скрипта IAT.txt

44.  [Глава 44](ch-44.md)
     * **Распаковка ACProtect 1.09g.f со всеми опциями защиты (3-я часть)**
     * ![](img/0/1.png) Возврат украденных байтов и OEP
     * ![](img/0/1.png) Борьба с антидампом
     * **Как сделать вставку, если секция, которую нужно создать, занята (дополнение к главе 44)** [Сноска 1](#footnote1)

45.  [Глава 45](ch-45.md)
     * Распаковка ReCrypt 0.80. (Этот крэкми в Olly не запускается, поэтому Рикардо показал методы, обычно помогающие добиваться запуска в отладчике.)
     * **Другой метод распаковки с использованием утилит Estricnina и Pokemon AntiAttach.** (Дополнение, написанное Arapumk’ом о другом способе атаки этого упаковщика. Показан альтернативный метод, к которому мы не привыкли.)

46.  [Глава 46](ch-46.md)
     * **Программа с собственной защитой Patrick.exe (1-я часть)**
     * ![](img/0/1.png) Проверка запустившей крэкми программы (API-функция Process32Next)
     * ![](img/0/1.png) Разрешение конфликта с HideOD
     * ![](img/0/1.png) Проверка модулей Explorer.exe (API-функция Module32First)
     * ![](img/0/1.png) Проверка пути до Explorer.exe (API-функция GetWindowsDirectory)
     * ![](img/0/1.png) Обфускация для сокрытия кода в листинге
     * ![](img/0/1.png) Получение пути крэкми (API-функция GetModuleFileName)
     * ![](img/0/1.png) Проверка наличия другого процесса крэкми (API-функция CreateMutex)
     * ![](img/0/1.png) Создание второго процесса крэкми (API-функция CreateProcess)
     * ![](img/0/1.png) Разрешение конфликта с HideOD

47.  [Глава 47](ch-47.md)
     * **Программа с собственной защитой Patrick.exe (2-я часть)**
     * ![](img/0/1.png) Остальные защиты и способы их обхода
     * ![](img/0/1.png) Запуск Patrick.exe в Olly без проблем
     * **Метод логировки API-функций, используемых программой**

48.  [Глава 48](ch-48.md)
     * Распаковка PeSpin 1.3.04.f (1-я часть)
     * ![](img/0/1.png) Возврат украденных байтов

49.  [Глава 49](ch-49.md)
     * **Распаковка PeSpin 1.3.04.f (2-я часть)**
     * ![](img/0/1.png) Восстановление IAT
     * ![](img/0/1.png) Борьба с антидампом

50.  [Глава 50](ch-50.md)
     * **Распаковка ReCrypt 0.80**
     * ![](img/0/1.png) API-функция OutputDebugString

51.  [Глава 51](ch-51.md)
     * **Распаковка ASProtect 2.3.04.26.a (1-я часть, системные драйверы SYS)**
     * ![](img/0/1.png) Плагины OllyBone и Weasle
     * ![](img/0/1.png) Функционирование OllyBone
     * **Обсуждение проблемных моментов этой главы:** *[Сноска 2](#footnote2)*, *[Сноска 3](#footnote3)*

52.  [Глава 52](ch-52.md)
     * Распаковка ASProtect 2.3.04.26.a (2-я часть)
     * ![](img/0/1.png) Ликвидация переадресации с помощью скрипта Hiei

53.  [Глава 53](ch-53.md)
     * Распаковка TPPpack (альтернативный вариант) \*
     * ![](img/0/1.png) Поиск OEP и возврат украденного кода с помощью 1-го скрипта Ulaterck’а
     * ![](img/0/1.png) Восстановление IAT с помощью 2-го скрипта Ulaterck’а
     * \* Рикардо сначала приводит объяснение по туториалу Ulaterck’а, затем (о восстановлении IAT) — по туториалу Marciano (конкурс 97, уровень 4).

54.  [Глава 54](ch-54.md)
     * **Распаковка ExeCryptor 2.2.50.a с максимальным сжатием ресурсов/кодов/данных, без защиты (1-я часть)**
     * ![](img/0/1.png) Использование TLS callback (способы поиска с помощью различных утилит)

55.  [Глава 55](ch-55.md)
     * Распаковка ExeCryptor 2.2.50.a с максимальным сжатием ресурсов/кодов/данных, без защиты (2-я часть)
     * ![](img/0/1.png) Написание скрипта для восстановления IATа
     * ![](img/0/1.png) Дамп



56.  [Глава 56](ch-56.md)
     * **Распаковка ExeCryptor 2.2.50.b**
     * ![](img/0/1.png) Работа с потоками
     * ![](img/0/1.png) Написание скрипта для восстановления IATа
     * ![](img/0/1.png) Дамп



57.  [Глава 57](ch-57.md)
     * **Распаковка ExeCryptor 2.2.50.c/d/e/f/g**
     * ![](img/0/1.png) Использование нароботок из предыдущих глав об ExeCryptor
     * ![](img/0/1.png) Распаковка ExeCryptor 2.2.50.c с включенной опцией "Kill Registry/File monitors"
     * ![](img/0/1.png) Распаковка ExeCryptor 2.2.50.d с включенной опцией "Debug messages"
     * ![](img/0/1.png) Распаковка ExeCryptor 2.2.50.e с включенной опцией "Active watch"
     * ![](img/0/1.png) Распаковка ExeCryptor 2.2.50.f с включенной опцией "Patch protection"
     * ![](img/0/1.png) Распаковка ExeCryptor 2.2.50.g с включенной опцией "Anti-trace"



58.  [Глава 58](ch-58.md)
     * **Продолжаем ломать ExeCryptor**

* * *

*Сноска 1*

Меня спросили, как сделать вставку, если секция, которую нужно создать, уже занята.
Так было и на моем компьютере: начало секции антидампа оказалось 150000, где система создает кучу со значениями, необходимыми для работы программы. Если произвести только стирание и копирование, антидамп выполняться не будет:

```
0046B017 60 PUSHAD
0046B018 90 NOP
0046B019 68 00400000 PUSH 4000
0046B01E 68 00800200 PUSH 28000
0046B023 68 00001500 PUSH 150000
0046B028 FF15 A4094600 CALL NEAR DWORD PTR DS:[4609A4] ;kernel32.VirtualFree
0046B02E 90 NOP
0046B02F 6A 04 PUSH 4
0046B031 68 00200000 PUSH 2000
0046B036 68 00C00300 PUSH 3C000
0046B03B 68 00001500 PUSH 150000
0046B040 FF15 A8094600 CALL NEAR DWORD PTR DS:[4609A8] ;kernel32.VirtualAlloc
0046B046 90 NOP
0046B047 6A 04 PUSH 4
0046B049 68 00100000 PUSH 1000
0046B04E 68 00C00300 PUSH 3C000
0046B053 68 00001500 PUSH 150000
0046B058 FF15 A8094600 CALL NEAR DWORD PTR DS:[4609A8] ;kernel32.VirtualAlloc
0046B05E 61 POPAD
0046B05F 90 NOP
```

Здесь стирается секция 150000, а затем копируется секция дампа. Кроме того, следует позаботиться о значениях кучи, которые нужны программе для ее нормальной работы. После запуска и остановки в Entry Point дампа они уже там, то есть нужно сделать так, чтобы после копирования всей секции они были там без каких-либо изменений, и тогда программа будет выполняться. Думаю, что нет необходимости писать об этом отдельный туториал, следует лишь добавить API функцию перед стиранием секции, а затем производить размещение и копирование, не стирая при этом данные кучи, используемые системой, которые были при запуске экзешника и заполнении секции. *\[Мне мысль автора не совсем ясна, поэтому перевод этого абзаца может оказаться неточным. Замечания по переводу можно направить мне в мой блог [bpmx.livejournal.com](http://bpmx.livejournal.com) — комментарии открыты для всех.\]*

Рикардо Нарваха
* * *
*Сноска 2*

**Ralba**
—Error 45, а от второго волосы дыбом встают. Такое впечатление, что процессор вот-вот из материнки выскочит, хе-хе. И это не считая того, что я не могу запустить данную версию ASProtect’а из Проводника простым двойным кликом! Так происходит только со мной или есть и другие? Я уж и копировал в различные места на жестком диске, чтобы изменить путь, но всё без толку…


**Рикардо Нарваха**
Этот упаковщик весьма чувствителен из-за RDTSC. Если он не запускается вне отладчика, то в Olly будет работать еще меньше.


**OtupAtpaxa**
Этот упаковщик — однозначно гадина в высшей степени, хотя, согласно Рикардо, это наименее защищенная версия. У меня на него почти весь вечер уходит — проще будет написать скрипт, чем заставить его дойти до OEP! Из 20-ти попыток дойти до OEP удается 1, и ничего с этим не поделаешь. Он просто перемалывает меня в своих жерновах! Кроме того, данный анпэкми, как верно заметил Ralba, не только не работает в Olly, но и не запускается двойным кликом в Windows’е. Я крайне разочарован. Надеюсь, кто-нибудь поможет с ним разобраться :-)


**Рикардо Нарваха**
Если анпэкми не запускается вне отладчика, нужно скопировать его в другую папку, и там должен заработать. Пробовал новую версию Olly Advanced с включенным драйвером Anti-RDTSC fakerdtsc (метод 1)? Однажды я никак не мог запустить программу; перезагрузил, и проблема исчезла.


**DAMIAN**
Otup, это потому что ты не пробовал приаттачиться. <…> Скрипт работает с OEP, я его еще не смотрел.
dapaf


**OtupAtpaxa**
Привет, Рикардо! Изменять папки я попробовал, однако результат всегда эвристический: 2 раза программа запускается, а 8 раз — нет… Большое спасибо за файлы, отправленные тобой этим вечером, но я их еще не смотрел. Надеюсь, завтрашний день будет более удачным.

dapaf, твоя идея, конечно, хороша, но у меня приаттачиться не получается… Полагаю, что если есть возможность присоединиться к запущенному (и остановленному) процессу, то можно будет дойти до какого-нибудь вызова антидампа. Это, конечно, лучше, чем ничего.


**Рикардо Нарваха**
Я бы сказал, что проблема скорее в процедуре антидампа, которая переписывает API-функцию из DLL’ки в созданную упаковщиком область памяти и модифицирует уже выполненный CALL, чтобы он указывал на эту область и чтобы после его выполнения было сложно идентифицировать API-функцию, поскольку он больше на нее не указывает. По-моему, трудность заключается именно в этом.


**Ralba**
Простите, маэстро, но что такое RDTSC?


**Рикардо Нарваха**
Инструкция RDTSC позволяет определять число циклов, прошедших с момента включения компьютера и может использоваться подобно GetTickCount для определения промежутка времени между двумя вызовами команды, что и применено в исследуемом ASProtect’е, но не два, а несколько раз. Эта команда осложняет процесс взлома и перехват API-функций, поскольку во время ручной трассировки каждый раз при проходе через RDTSC происходит приостановка выполнения, а это влияет на результат и далее начинаются проблемы. В те времена, когда еще не было драйверов Anti-RDTSC, приходилось останавливаться на командах RDTSC (с помощью пошаговой трассировки, либо ища во всём коде инструкции RDTSC и устанавливая на каждую BP, либо запуская условную трассировку Trace into с остановками на RDTSC), а затем после выполнения инструкции изменять значения регистров EAX и EDX, обнуляя или сокращая период времени между двумя вызовами. Теперь же появились специальные драйверы, входящие в состав Olly Advanced под названием Anti13 RDTSC (fakerdtsc) — они изменяют в нулевом кольце свойства инструкции, чтобы блокировать ее работу в третьем. Данные драйверы изменяют один флаг, и это дает нам возможность работать с программой в Ring3. Таким образом, если в OllyDbg не задействовать драйвер Olly Advanced fakerdtsc, программа выполняться не будет. Могу предположить, что иногда она будет отказываться работать, если время вычислено очень точно. Так бывает, когда программисты предпринимают отчаянные антиотладочные меры.


**OtupAtpaxa**
Привет, Рикардо! Действительно, с последней версией Olly Advanced программа работает немного лучше. Архив fakerdtsc.rar теперь уже не столь актуален, так как он содержит файл fakerdtsc.sys, создаваемый во время работы Olly. Напоследок, перед тем как поднять белый флаг, я хотел бы узнать: может ли скрипт выяснить, какая инструкция является анти-дампом, поскольку на моем компьютере это иногда 015E0000, а иногда — 015C0000… А также — может ли он изменить инструкции, производящие копирование API-функций. Я нашел место, где используется имя API-функции, но оно изменяется при каждом выполнении… Спасибо.

* * *
*Сноска 3*


**Рикардо Нарваха**
Я добавил несколько файлов, которые можно скачать по прежней ссылке — это конфигурация Olly Advanced, необходимая для сокрытия отладки, поскольку заставить программу выполняться в Olly довольно трудно, а в туториале об этом сказано было недостаточно. Поэтому я перебрал комбинации настроек плагина и в конце концов заставил анпэкми работать. Я использовал Hide Debugger 1.24 ***\[[ссылка](files/19/HideDebugger124.7z)\]*** со всеми установленными галками и Olly Advanced ***\[[ссылка](files/50/OllyAdvanced-1.26-beta10.7z)\]***, настроенный как показано на скриншотах ***\[[ссылка\]](files/51/CONFIGURACION.DEL.OLLY.ADVANCED.para.este.asprotect.7z)***. Если у вас и теперь программа не работает, то вам придется найти свою собственную конфигурацию плагина таким же образом, как это сделал я — просто удаляя и устанавливая галки, хе-хе.


*\[Перевод оглавления с испанского: Рома Стремилов, 01.2010, 05.2010\]*
