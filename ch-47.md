# Глава 47 - Крэкми от Fatmike. Часть 2

Продолжим с Patrick’ом [\[ссылка\]](.gitbook/assets/files/46/patrick.7z). Когда я дошел до места, на котором мы остановились в предыдущей главе, то заметил, что после восстановления оригинальных байтов команды, где был бесконечный цикл для присоединения, было бы хорошо вместо обычного BP установить на эту инструкцию аппаратный брейк, поскольку обычный обнаруживается и DLL’ка не запускается. Установка HE обеспечивает остановки не хуже, а после появления в списке загруженных модулей AntiDebugDll.dll можно установить в ее секции кода BPM ON ACCESS и оказаться на ее Entry Point:

![](.gitbook/img/47/1.png)

![](.gitbook/img/47/3.png)

Это Entry Point DLL’ки. В данный момент все модули загружены. Теперь можно приступать, но продвигаться следует постепенно, шаг за шагом.

Наша задача — оказаться в OEP крэкми с помощью OllyDbg, а это сделать, как уже упоминалось, сложнее, чем с помощью способа, не использующего Олли. Но в данном случае мы пользуемся именно Олли, поэтому оставим тот способ на потом и продолжим наш сложный путь сквозь патрицианскую защиту, как сказал Jack.

Давайте снова попадем в то место, где создается второй процесс: вначале изменим PID Олли на PID Проводника, затем, дойдя до CreateProcessA, изменим параметр dwCreationFlags для заморозки процесса и выполним эту функцию до ее команды RET. Далее установим бесконечный цикл в ntdll.dll, как это было описано в предыдущей главе. Присоединимся ко второму процессу. Затем, после снятия бесконечного цикла, установим на той же строке аппаратный брейк. Произведя нескольких остановок, дождемся загрузки AntiDebugDll.dll, после чего установим BPM ON ACCESS в секцию ее кода — и окажемся в ее EP. Всё это было проделано в предыдущей главе. Теперь открыты два OllyDbg: в одном отлаживается первый процесс, который мы назовем РОДИТЕЛЕМ (он находится в точке возврата из API-функции CreateProcessA), а в другом — второй процесс, остановленный на EP AntiDebugDll.dll, пусть он будет ПОТОМКОМ.

Если вам что-либо из этого не понятно, то перед продолжением исследования крэкми стоит повторить пройденный материал и попрактиковаться, так как далее будет не проще (даже сложнее, хе-хе).

![](.gitbook/img/47/5.png)

Таким образом, в родителе мы остановились на возврате из API-функции CreateProcessA.

![](.gitbook/img/47/7.png)

А в потомке — на EP AntiDebugDll.dll. Чтобы видеть, что это именно потомок, в этом отладчике желательно установить другую цветовую схему. Так я делаю не только для того, чтобы читателям было понятнее, какой из двух процессов я имею в виду — это и мне самому помогает не запутаться при взломе.

Теперь, по идее, нужно эмулировать одновременное выполнение двух процессов, но это невозможно. Однако известно, что процесс выполняется до места, где он ожидает действий другого, поэтому можно довести один процесс до состояния ожидания, а далее продолжать работать с другим.

Мы начнем с потомка. Как известно, если при его запуске он замечает что-либо подозрительное, то через несколько секунд закрывается. Следовательно, перед этим должна осуществляться проверка, какой это процесс: первый или второй, родительский или дочерний. В результате процесс станет выполнять соответствующую роль родителя или потомка. Важно понять, что, хотя эти процессы похожи (так как начинают выполняться с одной и той же строки), но, тем не менее, первый обнаруживает, что это первый процесс, а второй — что второй, поэтому они решают различные и даже противоположные задачи.

Как мы уже знаем, с помощью API-функции CreateMutexA проверяется, первый ли это запуск процесса, поэтому установим на нее BP в потомке.

![](.gitbook/img/47/9.png)

Остановка произошла здесь. Родитель уже выполнял эти действия и сейчас мьютекс уже существует, поэтому API-функция теперь должна возвратить 0B7 (ERROR\_ALREADY\_EXISTS), а не 00 (ERROR\_SUCESS), как это было при создании мьютекса родителем. Дойдем до команды RET API-функции:

![](.gitbook/img/47/11.png)

Код возвращенной ошибки говорит, что это была попытка создания уже созданного родителем мьютекса. Важно понимать, что когда программа обнаружит код спровоцированной ошибки B7, возвращенной API-функцией, она начнет выполнять совсем другую роль, нежели родитель, поэтому данный процесс надо будет рассматривать как отдельный процесс-по­то­мок.

![](.gitbook/img/47/13.png)

Теперь вызывается API-функция, возвращающая последнюю произошедшую ошибку, и программа получает значение B7, которое отладчик уже показал, т.е. ERROR\_ALREADY\_EXISTS.

![](.gitbook/img/47/15.png)

![](.gitbook/img/47/17.png)

Затем это значение сохраняется. Если установить BPM ON ACCESS на ту ячейку памяти, где оно сохраняется и нажать RUN, то остановка произойдет в момент его считывания перед сравнением.

![](.gitbook/img/47/19.png)

Здесь сохраненный код сравнивается с 0B7.

![](.gitbook/img/47/21.png)

При истинном результате сравнения команда SETE поместит в EAX единицу. Далее идет решающий переход: если регистр EAX окажется ненулевым, то процесс станет потомком, иначе — родителем. В данном случае переход выполняется, поскольку это дочерний процесс. Если бы это был родитель, то переход бы не состоялся. Таким образом, здесь ход выполнения процессов разветвляется: до сих пор они делали одно и то же, а теперь родителю надо будет подтвердить, что он был создан Проводником и будет вызвана CreateProcessA для создания потомка. А то, что будет делать потомок, мы рассмотрим далее.

Для отслеживания API-функций существуют весьма полезные утилиты, подобные Kam и APISpy. Они логируют используемые в программе API-функции и помогают избежать лишней трассировки. Давайте попытаемся сделать собственный Kam с помощью Olly, что позволит нам переходить от API-функции к API-функции, сэкономит время и поможет в изучении таких насыщенных программ, как наш крэкми.

Прежде всего, надо в потомке найти IAT DLL’ки. Не трассируя, посмотрим в листинге выше команду CALL, вызывающую какую-либо API-функцию:

![](.gitbook/img/47/23.png)

Вот подходящий вызов: он берет значение из адреса 1000C034, который должен соответствовать элементу IAT’а. Посмотрим его в DUMP’е:

![](.gitbook/img/47/25.png)

Это IAT; после нахождения ее начала и конца установим BPM ON ACCESS на всю таблицу:

![](.gitbook/img/47/27.png)

Сделав то же самое в родителе, получим второй собственный Kam. Конечно, IAT там находится по тем же адресам:

![](.gitbook/img/47/29.png)

Таперь у нас есть два собственных Kam’а. Следует заметить, что они позволяют останавливаться на API-функциях из IAT’а DLL’ки. В случае с API-функциями не из IAT’а, полученными с помощью GetProcAddress, надо будет установить HARDWARE BPX ON ACCESS куда потребуется. Важно, что это работает с API-функ­циями из IAT’а, где наш Kam будут функционировать без нужды в чем-либо еще, хе-хе.

Вернемся к потомку, нажмем F9 и посмотрим, в какой API-функции он остановится. Кроме того, при каждой остановке будем смотреть параметры, передаваемые функции.

![](.gitbook/img/47/31.png)

Однако, это избавило нас от часов трассировок: первая же остановка в потомке произошла снова в CreateMutexA при создании еще не существующего мьютекса:

![](.gitbook/img/47/33.png)

Если вспомнить, то название рассмотренного нами ранее мьютекса, созданного родителем, было MYFIRSTINSTANCE, что означает: "мой первый экземпляр". А новый мьютекс называется MYMAININSTANCE, что значит: "мой главный экземпляр"; он создан потомком при выполнении программы, поэтому главный.

Нажмем F8, чтобы пройти API-функцию:

![](.gitbook/img/47/35.png)

Не думаю, что результат этой второй проверки в процессе потомка на что-то влияет. Так как больше процессов не создается, мы не будем смотреть сравнение значений — в данном случае это не столь важно. Лучше нажмем F9 и перейдем с помощью нашего OllyKam’а к следующей API-функции, хе-хе.

![](.gitbook/img/47/37.png)

Эта функция возвращает последнюю ошибку, произошедшую в результате вызова CreateMutexA. Нажмем F9 и остановимся на очередной API-функции:

![](.gitbook/img/47/39.png)

Чтобы можно было произвести какие-либо изменения в текущем процессе, надо получить его псевдохэндл. Данная API-функция возвращает FFFFFFFF, то есть хэндл текущего процесса (или псевдохэндл). Нажмем F8:

![](.gitbook/img/47/41.png)

А теперь — F9:

![](.gitbook/img/47/43.png)

Для тех, кто не знаком с данными API-функциями, это будет хорошим упражнением. Если бы мы были на экзамене, а я был учителем, то я бы обязательно спросил: "Что возвращает эта API-функция?" Нам необходимо знать это до такой степени, чтобы и без помощи Win32 API, а только увидев это, мы и без нажатия на F8 могли понять, что здесь происходит, хе-хе.

![](.gitbook/img/47/45.png)

Поскольку параметр функции — ntdll.dll, то после нажатия на F8 получим основание этой DLL’ки, которое затем станет параметром GetProcessAddress при поиске адреса новой API-функции.

![](.gitbook/img/47/47.png)

Надеюсь, я был прав. Нажмем F9:

![](.gitbook/img/47/49.png)

Ну, посмотреть чуть ниже было не так трудно, хе-хе.

Вот параметры функции:

![](.gitbook/img/47/51.png)

Хмм, этот вызов даст программе адрес указанной API-функции. Снова F9:

![](.gitbook/img/47/53.png)

![](.gitbook/img/47/55.png)

Итак, поскольку здесь пропатчивается API-функция того же самого процесса, то это реализация части системы антиотладки. Для тех, кто желает изучить данный вопрос глубже, можно сказать так: здесь изменяются настройки доступа упомянутой API-функции, чтобы в ней можно было писать.

![](.gitbook/img/47/57.png)

Изменения вносятся API-функцией WriteProcessMemory. Посмотрим ее параметры:

![](.gitbook/img/47/59.png)

Итак, что за байт будет записан в этом процессе с помощью псевдохэндла FFFFFFFF по адресу исследуемой API-функции?

![](.gitbook/img/47/61.png)

В этой процедуре есть вызов DbgBreakPoint. Если вспомнить, то после присоединения остановка произошла именно на DbgBreakPoint, так что данное место имеет к этому отношение. Выполнив API-функцию WriteProcessMemory, посмотрим, что изменится в DbgUiRemo­teBreakin:

![](.gitbook/img/47/63.png)

Эта функция аннулируется установкой команды RET в ее начале.

Теперь опять воспользуемся нашим OllyKam’ом, который достаточно много рассказывает нам о происходящем в программе и о вызываемых в ней API-функциях:

![](.gitbook/img/47/65.png)

Снова извлекается основание ntdll.dll. Далее идет вызов GetProcAddress для поиска адреса процедуры DbgBreakPoint, чтобы пропатчить и ее.

![](.gitbook/img/47/67.png)

![](.gitbook/img/47/69.png)

Устанавливаются настройки доступа для чтения/записи. Далее:

![](.gitbook/img/47/71.png)

Теперь будут внесены изменения. Посмотрим параметры этой API-функции:

![](.gitbook/img/47/73.png)

Она изменит один байт в процедуре DbgBreakPoint. Взглянем на нее до внесения изменений:

![](.gitbook/img/47/75.png)

После нажатия на F8 начало функции станет таким:

![](.gitbook/img/47/77.png)

То есть удалена команда INT3, которая вызывает исключение, дающее нам возможность приаттачиться, а вместо нее установлена инструкция RET, не позволяющая нам это сделать. Хе-хе, OllyKam действительно помогает тем, кто желает изучить систему антиотладки! Нажмем F9:

![](.gitbook/img/47/79.png)

Остановились на API-функции OpenMutexA, которая используется при работе с мьютексами. Один из них уже создан родителем, и это можно проверить в окне хэндлов родительского процесса: там есть мьютекс под названием WAIT:

![](.gitbook/img/47/81.png)

В потомке этот мьютекс ни разу не вызывался, и чтобы с ним можно было работать, нужно получить его хэндл с помощью функции OpenMutexA.

![](.gitbook/img/47/83.png)

Как это обычно бывает при успешном открытии объектов, хэндл возвращается в регистре EAX.

![](.gitbook/img/47/85.png)

Теперь он загружен и появился в списке хэндлов потомка.

![](.gitbook/img/47/87.png)

После сравнения полученного хэндла с нулем и выяснения, что такой объект уже был создан родителем (поскольку можно получить его хэндл), был предотвращен вызов ExitProcess. Это очередная проверка, в результате которой потомок мог закрыться. Нажмем F9:

![](.gitbook/img/47/89.png)

Вызов WaitForSingleObject — еще одно критическое место потомка, где придется бороться с Patrick’ом. Как известно, если родитель не выполнит определенные действия за несколько секунд или войдет в цикл и потратит время, потомок закроется. Данная функция как раз в этом и виновна. Посмотрим ее параметры:

![](.gitbook/img/47/91.png)

Первый — это хэндл мьютекса, названного WAIT. Значит, потомок будет ожидать от родителя определенных действий, а после освобождения этого мьютекса выполнение потомка продолжится. Проблема заключается во втором параметре, где указан период в 5000 мс: если за этот промежуток времени потомок не дождется от родителя освобождения мьютекса, он будет закрыт, и, как это ни прискорбно, закроется также и потомок. Посмотрим, не трассируя, что идет далее после вызова этой функции:

![](.gitbook/img/47/93.png)

![](.gitbook/img/47/95.png)

Здесь происходит сравнение с нулем, и, в зависимости от результата, выполняется или не выполняется обход JMP’а, ведущего к вызову ExitProcess.

![](.gitbook/img/47/97.png)

![](.gitbook/img/47/99.png)

То есть, во избежание закрытия потомку следует не выходить из этой API-фун­кции до тех пор, пока родитель не освободит мьютекс WAIT. Мы просто изменим параметр времени dwMilliseconds (Timeout в Olly) на INFINITE (бесконечность), и потомок не сможет выйти из функции WaitForSingleObject:

![](.gitbook/img/47/101.png)

После замены значения параметра 00001388 на FFFFFFFF (–1), установим BP сразу за API-функцией, чтобы после освобождения мьютекса родителем произошла остановка:

![](.gitbook/img/47/103.png)

Теперь нажмем F9:

![](.gitbook/img/47/105.png)

Как видим, потомок выполняется, и это будет продолжаться до тех пор, пока родитель не окажется в области, где освобождается мьютекс. Поэтому теперь мы ничего не сможем сделать в потомке. В момент освобождения мьютекса родителем произойдет остановка на установленном нами брейке, а сейчас, когда потомок вечно выполняется, есть время для продолжения работы с родителем.

Не стоит забывать, что если бы мы не изменили заданный в миллисекундах параметр времени API-функции WaitForSingleObject, это встревожило бы потомка и он перестал бы ждать родителя и отправился бы к ExitProcess, хе-хе. Бедный сын — воспитав его, мы заставили его послушно ожидать, хе-хе.

Теперь настала очередь трудиться родителю, поэтому начнем направлять его с помощью его OllyKam’а. Нажмем F9, чтобы узнать, что он будет делать.

Остановка произошла на API-функции Sleep, которая заставляет потерять его немного времени. Продолжая нажимать F9, пройдем не очень важную API-функцию и дойдем досюда:

![](.gitbook/img/47/107.png)

Параметры этой функции стоит рассмотреть, поскольку здесь организован гнусный трюк и нужно быть настороже.

Но перед тем как продолжать объяснение трюка, следует заметить, что в данном случае API-функция CreateFileA используется для обнаружения изменения кода. Установленные брейки изменяют код, а это после сравнения дает различия, которые потом приводят к плохой расшифровке программы. Поэтому все BP следует удалить. Можно оставить BPM ON ACCESS, который используется в OllyKam’е, но придется удалить все BP **как в родителе, так и в потомке,** а BP, который мы поместили для остановки потомка после прекращения вечного выполнения, нужно заменить на HPB ON EXECUTION, иначе возникнут проблемы при расшифровке.

![](.gitbook/img/47/109.png)

Эти BP в родителе нужно удалить все, даже One-shot, останавливающий OllyDbg на EP, так как он модифицирует код. А также следует удалить все BP в потомке.

После оставления насиженного добра можно продолжать изучение трюка, реализованного с помощью API-функ­ции CreateFileA. Но теперь мы не будем устанавливать ни одного обычного брейкпоинта — все брейки должны быть либо BPM, либо HE.

Вот параметры API-функции CreateFileA:

![](.gitbook/img/47/111.png)

Здесь происходит что-то странное, что я считаю багом OllyDbg — другого объяснения я не нахожу. Если кто-то, прочитав дальнейшее, узнает, почему так происходит, скажите мне. Я никогда не видел такого противооллиного трюка и у меня нет никакой информации о том, что в API-функции CreateFileA может использоваться баг Olly. Поиски в форумах ничего не дали. Возможно, друг Fatmike обнаружил какой-то новоявленный баг. И только из-за того, что я довольно давно в крэкинге, после усиленных поисков удалось вычислить, что здесь происходит. Я постараюсь объяснить эти довольно необычные вещи как можно более ясно.

Если попытаться изменить в DLL’ке хотя бы один байт и сохранить изменения, то при следующем запуске программа узнает, что произошло изменение, дойдет до OEP, но окажется плохо распакованной, т.е. будет состоять из мусора, вызывающего ошибки.

Дело в том, что программа с помощью CreateFileA проверяет AntiDebugDll.dll, а затем с помощью ReadFile считывает и сравнивает байты файла с теми, которые выполняются, проверяя таким образом их равенство. При обнаружении несоответствия даже одного байта происходит плохая распаковка. Так должно быть в случае, если изменен один или более байтов, но мы в файле ничего не меняли, а делали всё в памяти, поэтому после считывания файла байты должны совпасть (если, конечно, не установлены BP). Однако, при использовании OllyDbg произойдет то же самое: программа плохо расшифруется и в OEP окажется мусор. Похоже, в Olly происходит нечто, из-за чего при прочтении файла программа ведет себя так, как если бы ее байты были изменены.

Вернемся к API-функции CreateFileA и ее параметрам:

![](.gitbook/img/47/111.png)

Большинство из них довольно стандартны, но параметр dwShareMode требует особого внимания. Давайте выясним его возможные значения по Win32 API:

![](.gitbook/img/47/113.png)

Здесь сказано, что если этот параметр равен FILE\_SHARE\_READ, то следующий вызов файла будет успешен только при установке параметра dwDesiredAccess в GENERIC\_READ. Установка нуля вместо FILE\_SHARE\_READ запрещает разделение доступа к файлу и следующая попытка его открыть будет тщетна, поскольку файл уже открыт.

В нашем случае в следующий раз файл будет открыт только при установке параметра GENERIC\_READ. Нажмем F8, чтобы посмотреть, будет ли возвращен хэндл:

![](.gitbook/img/47/115.png)

Хэндл получен. Теперь с помощью OllyKam’а перейдем к очередной API-функции:

![](.gitbook/img/47/117.png)

Здесь вызывается CreateFileMappingA, создающая проекцию файла в памяти, о чем можно прочитать в новых туториалах этого курса. Она не сильно влияет на функционирование программы. С ее помощью последняя получает хэндл проецированного файла.

![](.gitbook/img/47/119.png)

Затем вызывается API-функция MapViewOfFile, которая мэппирует файл в память с помощью полученного хэндла. После нажатия на F8 станет известен адрес, по которому загружена проекция:

![](.gitbook/img/47/121.png)

AntiDebugDll.dll загружена в память побайтно, начиная с адреса 9F0000. Казалось бы, теперь эти байты должны быть сравнены с теми, которые выполняются, но этого не происходит — сравнивается несколько байтов заголовка, а вовсе не код программы. Посмотрим в дампе загруженные байты DLL’ки:

![](.gitbook/img/47/123.png)

Они должны совпадать с байтами выполняющейся в данный момент DLL’ки, загруженной по адресу 10000000. И действительно, это те же самые байты:

![](.gitbook/img/47/125.png)

Программисту было бы легко сделать сравнение прямо здесь, поскольку байты уже загружены, и в секции, созданной проецированием файла в память, нельзя устанавливать ни BPM ни HE. Можно было замести следы с помощью переходов и начать сравнение здесь, проверяя наличие измененных байтов, но, как бы это удивительно ни было, сравниваются только 4 или 5 значений в заголовке. Я трассировал дальше с помощью F7, так как в секции 9F0000 нельзя устанавливать ни BPM, ни HE. После долгой бессмысленной трассировки я заметил, что байты почему-то не сравниваются. Было бы проще установить брейки, но пришлось всё делать вручную. Это была одна из причин подозревать, что автор что-то замышляет. Затея, подобно первым шагам ребенка, завершилась, чтобы продолжиться позже. Какая-то причина однозначно существует!

Что ж, далее воспользуемся OllyKam’ом:

![](.gitbook/img/47/127.png)

Здесь считывается размер файла, чтобы узнать, был ли он изменен, а затем идут довольно нелепые сравнения расширения DLL’ки: dll или DLL, exe или EXE… Ну и пусть теряет свое время, если ему так хочется, хе-хе.

![](.gitbook/img/47/129.png)

Продолжим:

![](.gitbook/img/47/131.png)

Здесь удаляется проекция файла, загруженного в 9F0000, то есть эти байты больше не потребуются.

![](.gitbook/img/47/133.png)

Затем закрывается хэндл только что удаленной проекции файла, и это должно поставить точку в данном вопросе.

![](.gitbook/img/47/135.png)

Тем не менее, снова вызывается CreateFileA, но уже с такими параметрами:

![](.gitbook/img/47/137.png)

Параметр dwDesiredAccess по-прежнему установлен в GENERIC\_READ, и, согласно Win32 API, при существующем файле его хэндл можно получить снова. Нулевой dwShareMode приводит к тому, что хэндл не возвращается только при последующих вызовах CreateFileA, а здесь такого ограничения нет, и он должен возвратиться, поскольку файл существует. Посмотрим, что произойдет.

![](.gitbook/img/47/139.png)

Вместо хэндла файла OllyDbg возвратил код FFFFFFFF, а также показал сообщение об ошибке разделения доступа ERROR\_SHARING\_VIOLATION:

![](.gitbook/img/47/141.png)

Но мы видели, что всё было нормально и такой ошибки не должно было возникнуть. Похоже, предыдущее проецирование файла в память было выполнено неверно. После длительного исследования этой проблемы приходится сделать заключение, что в данном случае ошибочно функционирует сам отладчик.

Тот факт, что далее в программе хэндл, который должен был получен здесь, используется для чтения DLL’ки с помощью ReadFile и выполняется сравнение, когда это можно было сделать ранее, доказывает, что так было сделано намеренно. Кто-то нашел в OllyDbg баг и воспользовался им, чтобы в этом отладчике было невозможно считать байты файла и сравнить их: это приводит к тому же, что и изменение байтов — файл плохо расшифровывается. Все эти догадки были подтверждены экспериментально.

![](.gitbook/img/47/143.png)

После неудачной попытки получения хэндла вызывается ReadFile и производится чтение файла с параметром FFFFFFFF. В результате этого в регистре EAX оказывается ноль и происходит переход. Если бы был указан хэндл, то чтение выполнилось бы и переход бы не состоялся. Это означает, что пока программа выполняется в OllyDbg, адрес в образе 10003901 никогда не будет достигнут, поскольку выше происходит переход из-за неудачного выполнения ReadFile.

А что, если попытаться обеспечить нормальную работу ReadFile вне OllyDbg, чтобы эта функция возвратила единицу и переход, обходящий указанную область, не состоялся?

Я воспользовался не очень информативным способом: в файерволе Kerio есть возможность установить в настройках галку, чтобы программы спрашивали разрешения на запуск. Я запустил Patrick’а вне OllyDbg, и окошко с вопросом выскочило. Потом в Pupe [\[ссылка\]](.gitbook/assets/files/41/pupe2002.7z) установил EB FE по адресу ntdll.dll, из которого происходит переход на EP DLL’ки (на моем компьютере это 7C9111A4) и ответил в диалоговом окне. Затем установил другой цикл несколькими строками выше в 7C911199 и снял первый, и так поочередно устанавливал один и снимал другой, пока DLL’ка не загрузилась. Потом поместил бесконечный цикл в 10003901 и удалил циклы из ntdll, чтобы программа запустилась и осталась там зацикленной. Это позволило приаттачиться к процессу и увидеть, что он был остановлен в месте, в которое из OllyDbg никогда не попасть и которое достижимо только в случае возвращения функцией CreateFileA валидного хэндла. Таким образом было установлено, что программа выполняется нормально и в OllyDbg действительно есть баг.

Сделаем так, чтобы OllyDbg оказался в месте возвращения хэндла: повторим всё и дойдем до CreateFileA:

![](.gitbook/img/47/145.png)

Заставить OllyDbg возвратить валидный хэндл можно, заменив нулевое значение параметра dwShareMode единицей:

![](.gitbook/img/47/147.png)

Нажмем F8:

![](.gitbook/img/47/149.png)

И вот наш злополучный хэндл! Этот трюк, кажущийся таким простым, когда он известен, заставил меня провести целые дни в изнурительных попытках выяснить, что же здесь происходит. Так что на самом деле он совсем не прост…

Ладно, теперь продолжим юзать наш OllyKam:

![](.gitbook/img/47/151.png)

Дойдя до ReadFile, нажмем F8:

![](.gitbook/img/47/153.png)

Теперь EAX=1, как и должно быть, и обход адреса 10003901 не производится.

![](.gitbook/img/47/155.png)

Сразу после сравнения идет закрытие хэдла:

![](.gitbook/img/47/157.png)

Нужно быть внимательным, поскольку этот трюк используется несколько раз.

OllyKam, вперед!

![](.gitbook/img/47/159.png)

После нескольких остановок на не очень важных API-функциях снова вызывается CreateFileA, теперь уже для считывания файла Patrick.exe:

![](.gitbook/img/47/161.png)

![](.gitbook/img/47/163.png)

Так как это происходит впервые, то проблем не возникает и возвращается валидный хэндл, позволяющий работать с файлом.

![](.gitbook/img/47/165.png)

Теперь с файлом Patrick.exe происходит то же самое, что было с AntiDebugDll.dll: создается проекция файла в памяти, т.е. возвращается ее хэндл.

![](.gitbook/img/47/167.png)

Здесь копируются байты файла и API-функция возвращает адрес проекции, в данном случае на моем компьютере это 0AF0000:

![](.gitbook/img/47/169.png)

Если посмотрим этот адрес в дампе, то увидим отображение файла, содержащее считанные из файла Patrick.exe байты:

![](.gitbook/img/47/171.png)

Конечно, они будут совпадать с байтами Patrick.exe, находящимися по адресу 400000:

![](.gitbook/img/47/173.png)

Как видим, они абсолютно одинаковы. Далее, как это было с DLL’кой, сравнивается лишь несколько указателей заголовка, а не весь файл. Нажмем F9:

![](.gitbook/img/47/175.png)

Опять происходит проверка расширения, но на этот раз у экзешника Patrick.exe.

![](.gitbook/img/47/177.png)

Затем изображение файла удаляется, хотя сравнение было неполным.

![](.gitbook/img/47/179.png)

После пары незначительных API-функций изменяются настройки доступа потомка, находящегося в 401000; это нужно для расшифровки.

![](.gitbook/img/47/181.png)

Через параметры функции передаются хэндл потомка и разрешение на чтение/запись в секции, начинающейся в 401000.

![](.gitbook/img/47/183.png)

Так вызывается ReadProcessMemory — командой CALL, которая находится чуть ниже. Войдем в нее:

![](.gitbook/img/47/185.png)

Из параметров функции видно, что будет прочитано 16 байтов, начиная с адреса 401000. После их расшифровки они будут сохранены там же функцией WriteProcessMemory. В 401000 родителя окончательные байты не видны, но это не проблема, так как далее потомок произведет для него повторную расшифровку.

![](.gitbook/img/47/187.png)

![](.gitbook/img/47/189.png)

![](.gitbook/img/47/191.png)

Этот цикл будет повторяться вплоть до начала следующей секции в 406000, так что нам придется терпеливо удерживать клавишу F9 нажатой, увеличивая адрес, пока не окажемся рядом с 406000, где скорость надо будет замедлить, чтобы не проскочить.

![](.gitbook/img/47/193.png)

Скоро произойдет завершение цикла, поэтому следует отпустить клавишу и продолжать продвигаться уже отдельными нажатиями.

![](.gitbook/img/47/195.png)

Затем вызывается RealeaseMutex для освобождения потомка, который продолжает выполняться. Вспомним, что потомок выйдет из функции WaitForSingleObject только при освобождении родителем мьютекса, названного WAIT.

Если посмотреть параметры, то там указан хэндл 50 (так на моем компьютере):

![](.gitbook/img/47/197.png)

![](.gitbook/img/47/199.png)

Он, конечно же, соответствует мьютексу (или "Mutant", как указано в Olly) с именем WAIT. Сейчас потомок запущен и ожидает освобождения. После нажатия на F8 он будет освобожден и продолжит дальнейшее выполнение, поэтому на строке, следующей за вызовом WaitForSingleObject, был установлен брейк.

Нажмем F8, чтобы потомок освободился и остановился на HE.

Теперь свободны оба процесса, но мы пока продолжим работать с родителем: с помощью нашего OllyKam’а посмотрим, что будет далее:

![](.gitbook/img/47/201.png)

Этой API-функцией устанавливается другое ожидание, на этот раз в родителе:

![](.gitbook/img/47/203.png)

Единственный параметр задает период времени, после окончания которого происходит выход из API-функции. Но в данном случае это не случится, так как задана бесконечность; выход произойдет только в момент запуска потомка при вводе с клавиатуры или подобном событии.

Как и прежде, установим HE на следующей за вызовом команде и нажмем RUN:

![](.gitbook/img/47/205.png)

![](.gitbook/img/47/207.png)

Теперь родитель будет находиться в состоянии Running до тех пор, пока отпрыск не вырастет, а мы тем временем поможем ему подрасти, хе-хе. Продолжим юзать его Olly­Kam:

![](.gitbook/img/47/209.png)

На этот раз мьютекс WAIT будет освобожден в потомке, но на родителя это никак не повлияет, поскольку он находится в функции WaitForInputIdle, а не WaitForSingleObject и ожидает запуска потомка. Продолжим:

![](.gitbook/img/47/211.png)

Здесь потомок впервые считывает DLL’ку, чтобы проверить ее содержимое. Так как это происходит в первый раз, то проблем не возникает и извлекается валидный хэндл (скриншоты далее привожу без комментариев, ибо этот трюк уже объяснялся в родителе):

![](.gitbook/img/47/213.png)

![](.gitbook/img/47/215.png)

![](.gitbook/img/47/217.png)

![](.gitbook/img/47/219.png)

![](.gitbook/img/47/221.png)

Очередь доходит до ключевого вызова:

![](.gitbook/img/47/223.png)

![](.gitbook/img/47/225.png)

Как и прежде, обойдем баг Олли, изменив параметр dwShareMode на 1:

![](.gitbook/img/47/227.png)

Возвращен валидный хэндл.

![](.gitbook/img/47/229.png)

После пары незначительных API-функций вызывается ReadFile с хэндлом файла в параметрах для считывания его байтов и их сравнения. Так проверяется оригинальность файла.

![](.gitbook/img/47/231.png)

После проведения проверки хэндл закрывается.

![](.gitbook/img/47/233.png)

Теперь опять CreateFileA, но уже для экзешника Patrick.exe:

![](.gitbook/img/47/235.png)

Здесь проблем не возникает и хэндл возвращается.

![](.gitbook/img/47/237.png)

Происходит то же самое, что было в родителе, поэтому опустим подробности.

![](.gitbook/img/47/239.png)

![](.gitbook/img/47/241.png)

Теперь тот же трюк применяется к файлу Patrick.exe:

![](.gitbook/img/47/243.png)

Но мы изменим dwShareMode на 1, и хэндл будет возвращен:

![](.gitbook/img/47/245.png)

Продолжим нажимать на F9, и после нескольких API-функций дойдем до ReadFile, выполняющей проверку содержимого файла:

![](.gitbook/img/47/247.png)

![](.gitbook/img/47/249.png)

Опять то же самое! Что ж, изменим dwShareMode на 1. Предполагается, что если ты смог дойти досюда, то трюк уже раскрыт.

![](.gitbook/img/47/251.png)

Снова вызывается ReadFile для проверки.

![](.gitbook/img/47/253.png)

Дошли до GetCurrentProcess, которая возвращает псевдохэндл (хэндл выполняющегося процесса) FFFFFFFF. Наконец-то эти проверки пройдены и начинается что-то новое!

![](.gitbook/img/47/255.png)

![](.gitbook/img/47/257.png)

Здесь, как и ранее в родителе, разрешается чтение и запись в секцию кода программы для обеспечения функционирования ReadProcessMemory иWriteProcessMemory.

![](.gitbook/img/47/259.png)

Теперь вызывается WriteProcessMemory:

![](.gitbook/img/47/261.png)

После нажатия на F8 расшифруются первые 16 байтов и их можно будет увидеть по адресу 401000:

![](.gitbook/img/47/263.png)

Как видим, они расшифрованы верно.

![](.gitbook/img/47/265.png)

Остается добавить только штрих, хе-хе.

![](.gitbook/img/47/267.png)

Как и в прошлый раз, надо удерживать нажатой клавишу F9 до тех пор, пока не окажемся около 406000.

Область OEP расшифрована тоже правильно:

![](.gitbook/img/47/269.png)

![](.gitbook/img/47/271.png)

После окончания расшифровки создаются потоки защиты. Можно создать их замороженными, изменив параметр dwCreationFlags на 4.

![](.gitbook/img/47/273.png)

Это начало первого треда.

![](.gitbook/img/47/275.png)

А это — второго. Здесь снова будет произведена проверка выполняющихся процессов, поскольку видны соответствующие API-функции.

Итак, изменим параметр dwCreationFlags на CREATE\_SUSPENDED:

![](.gitbook/img/47/277.png)

После создания тредов на всякий случай снимем все аппаратные брейки, установим BPM ON ACCESS в секцию кода Патрика (начинающуюся в 401000) и BREAK ON ACCESS *\[**Break-on-access?**\]* в секцию кода AntiDebugDll.dll. После нажатия на F9 произошла незапланированная остановка в этой области:

![](.gitbook/img/47/279.png)

Можно оказаться на OEP Патрика быстрее, но так как галки в настройках исключений Олли оказались сняты и BPM установлен на всю секцию *\[**в секцию кода AntiDebugDll.dll**?\]**,* нажмем F9. Одно исключение генерируется этой командой:

![](.gitbook/img/47/281.png)

Это попытка перейти на адрес 00000000. После нажатия на Shift+F9 окажемся в OEP из-за остановки на BREAK ON ACCESS *\[**Рикардо что-то мудрит…**\]*

![](.gitbook/img/47/283.png)

Теперь можно было бы сразу приступить к сдампливанию, но мы поступим иначе: откроем еще один Patrick.exe в третьем OllyDbg и оставим его на системном брейке:

![](.gitbook/img/47/285.png)

Теперь скопируем в его первую секцию все байты первой секции потомка:

![](.gitbook/img/47/287.png)

Сохраним изменения: Copy to executable. Поскольку здесь правильная IAT, то проблем возникнуть не должно.

После открытия сохраненного Патрика в его первой секции содержится правильный код уже на System startup breakpoint. Но проблема в том, что далее запускается гнусная DLL’ка, поэтому перед ее удалением следует установить RET в ее EP и сохранить изменения:

![](.gitbook/img/47/289.png)

Потом откроем Patrick.exe в PE Editor’е [\[ссылка\]](.gitbook/assets/files/45/PEditor1.7.7z) и изменим настройки доступа всех секций на E0000020:

![](.gitbook/img/47/291.png)

А также есть CALL, который вызывает AntiDebugDll.dll — просто занопаем его:

![](.gitbook/img/47/293.png)

![](.gitbook/img/47/295.png)

Сохраним изменения и перезагрузим крэкми:

![](.gitbook/img/47/297.png)

Теперь он запускается, но чтобы DLL’ка вообще не загружалась, следует сделать следующее:

![](.gitbook/img/47/299.png)

Найдем в заголовке адрес начала IT — 406F3C.

![](.gitbook/img/47/301.png)

Это IT. Вспомним, что первые 5 DWORD’ов соответствуют 1-й DLL’ке. Узнаем ее имя по ее указателю — 4-му DWORD’у:

![](.gitbook/img/47/303.png)

Имя первой DLL’ки находится в 40712E, посмотрим его:

![](.gitbook/img/47/305.png)

Это WINMM.DLL, а вторая — AntiDebugDll.dll. Таким образом, если скопировать первые 5 DWORD’ов таблицы импорта и вставить их в позицию следующих, то AntiDebugDll.dll аннулируется и второй DLL’кой будет опять WINMM.DLL:

![](.gitbook/img/47/307.png)

Осталось только сохранить изменения и установить новое начало IT — 406F50:

![](.gitbook/img/47/309.png)

Сохранившись и перезагрузив крэкми, изменим адрес начала IT:

![](.gitbook/img/47/311.png)

Теперь будет так:

![](.gitbook/img/47/313.png)

После сохранения изменений и перезапуска крэкми противная DLL’ка не загружается и крэкми выполняется верно:

![](.gitbook/img/47/315.png)

![](.gitbook/img/47/317.png)

Хе-хе, вот и финал внушающего страх Патрика!

Простое же решение состоит в изменении настройки доступа 40000040 секции данных  файла Patrick.exe, что лишает его всех привилегий и нескольких строк ниже OEP, вызывающих ошибку при открытии в JIT-отладчи­ке OllyDbg. В таком виде можно дойти чуть ниже OEP, дождаться распаковки и сделать то же самое: скопировать и вставить первую секцию в третий OllyDbg, изменить IT — и он заработает, хе-хе.

Прощай, ПАТРИК! хе-хе

\[C\] Рикардо Нарваха, пер. Рома Стремилов, 01.2010
