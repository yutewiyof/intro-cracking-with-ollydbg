Глава 18 - Поиск переменного серийного номера. Часть 3
======================================================

Ок, в прошлой главе я упомянул, что собираюсь начать другую тему, связанную с обнаружением OllyDbg программами, запускающимися в ней (что, как правило, называется антиотладкой), как этого избежать и в каких случаях какие плагины можно использовать.

Но эту тему мы начнём в 19-ой главе, так как среди тех, кто изучает этот курс, нашлись люди, написавшие мне на почту и попросившие разобрать пример крэкми без кнопок как в прошлой части, и рассмотреть применение другой техники, использующей WM\_KEYUP.

Хорошо, используем для этого крэкми, предоставленный мне Stzwei’ем (спасибо ему), который называется \_4stz.exe ***\[[ссылка](.gitbook/assets/files/18/crackme_4stz.7z)\]***. Его мы и рассмотрим в данном туториале.

Откроем крэкми в OllyDbg.

![](.gitbook/img/18/1.png)

Находимся на точке входа. Посмотрим, какие здесь есть не запакованные строки.

![](.gitbook/img/18/2.png)

Отображается список строк, используемых программой.

![](.gitbook/img/18/3.png)

Здесь нет ничего интересного, посмотрим API-функции.

![](.gitbook/img/18/4.png)

![](.gitbook/img/18/5.png)

Уфф, так много.. Ок, запустим программу и окажемся в окошке, где вводится серийный номер.

![](.gitbook/img/18/6.png)

Видим, что кнопки регистрации нет. Введём полное имя.

![](.gitbook/img/18/7.png)

И установим BPX CONDITIONAL LOG на TranslateMessage – сначала обычный BPX.

![](.gitbook/img/18/8.png)

А когда вернёмся в крэкми, отредактируем установленный BP.

![](.gitbook/img/18/9.png)

Если кто-то не помнит значение WM-сообщения, которое собираемся использовать, то нужно перейти в окно W, которое показывает, какие окна используются программой.

![](.gitbook/img/18/10.png)

И отображается список окон, осталось только узнать числовое значение, поэтому кликаем правой кнопкой мыши.

![](.gitbook/img/18/11.png)

И мы попадаем в окно точек останова на сообщения с раскрываемым меню с WM-значениями.

![](.gitbook/img/18/12.png)

Поищем в списке WM\_KEYUP.

![](.gitbook/img/18/13.png)

Видим, что это 101, поэтому уберём всё, что мы делали только для того, чтобы узнать это значение, и вернёмся к BREAKPOINT CONDITIONAL LOG в TranslateMessage.

![](.gitbook/img/18/14.png)

И устанавливаем здесь MSG==101 (обратите внимание на двойной знак равенства), также, если бы не нашли значение, могли бы написать MSG==WM\_KEYUP и это бы сработало, но мне больше нравятся числовые значения. Здесь каждый волен поступать так, как ему это нравится.

Хорошо, точка останова трансформировалась в условную (розовый цвет).

![](.gitbook/img/18/15.png)

Делаем RUN и вводим первый символ неправильного серийного номера.

![](.gitbook/img/18/16.png)

И тут срабатывает условная точка останова.

![](.gitbook/img/18/17.png)

Смотрим параметры API-функции, по адресу 12ff78 находится структура, в которой сохранены значения нажатой клавиши, в данном случае это 39, что соответствует цифре 9.

Смотрим через DUMP указанную область памяти – нажимаем правую кнопку мыши на указанном адресе и выбираем FOLLOW IN DUMP.

![](.gitbook/img/18/18.png)

![](.gitbook/img/18/19.png)

Видим, что нам удалось узнать, куда помещается байт. Проблема в том, что это программа на Delphi (что мы рассмотрим в другой раз), и если мы установим на него BPM ON ACCESS, программа будет ходить сто раз туда-сюда, прежде чем дойдёт до сравнения, поэтому метод, который мы рассматривали в прошлый раз, работает здесь гораздо лучше, так что его мы и используем. В любом случае, вы уже знаете, как остановить программу по нажатию клавиши и как установить местонахождение байта. Разумеется, в крэкми, не написанном на Delphi, гораздо проще использовать BPM ON ACCESS.

И запускаем.

![](.gitbook/img/18/20.png)

Вводим 9898, идём в окно M и ищем по всей памяти.

![](.gitbook/img/18/21.png)

Нажимаем правую кнопку мыши и выбираем SEARCH.

![](.gitbook/img/18/22.png)

![](.gitbook/img/18/23.png)

И ищем строку 9898.

![](.gitbook/img/18/24.png)

Первое вхождение обнаруживается в стеке. Нажимаем CTRL+L несколько раз, чтобы увидеть, сколько раз оно в нём встречается.

Как только нам внизу отобразится жёлтым цветом слово ITEM NOT FOUND, выходим и возвращаемся в окно M.

![](.gitbook/img/18/25.png)

Оказываемся там, откуда искали, так что идём дальше вниз с помощью CTRL + L.

![](.gitbook/img/18/26.png)

Первый раз в этой секции, нажимаем CTRL + L, чтобы посмотреть, найдётся ли здесь что-либо.

Нет, ничего нет, если посмотрим область, находится вхождение чего-то подозрительного.

![](.gitbook/img/18/27.png)

Видим возможный серийный номер 418507, установим на это место BMP on ACCESS, чтобы посмотреть, не с ним ли происходит сравнение.

![](.gitbook/img/18/28.png)

Делаем RUN.

![](.gitbook/img/18/29.png)

Останавливаемся здесь и видим, что копируется моё имя.

![](.gitbook/img/18/30.png)

Видим, что каждый раз, когда печатаем, по новой копируется мой неправильный серийный номер, и с каждым следующим символом по новой копируется правильный серийный номер. Как только введём 6 символов, то установим на них BPM (помните, в предполагаемом серийном номере как раз 6 символов? – прим. пер.).

![](.gitbook/img/18/31.png)

Останавливаемся прямо на сравнении.

![](.gitbook/img/18/32.png)

Тут видим, что ESI и EDI указывают на неправильный и правильный серийные номера.

![](.gitbook/img/18/33.png)

Они сравниваются по четыре байта за оборот цикла. Проверим, является ли найденный серийник действительно верным.

![](.gitbook/img/18/34.png)

*(Сообщение гласит: "Поздравляю, победитель!" - прим. пер.)*

Видим, что не смотря на то, что это сложный крэкми, можно поймать точный момент, когда происходит сравнение, для чего нужно отслеживать местоположение неправильного серийного номера и ставить на него BPM.

Есть и другая возможность. Видим, что в памяти появляются 4 байта неправильного серийного номера.

![](.gitbook/img/18/35.png)

Он же, но уже из 5-ти первых байтов, чуть ниже.

![](.gitbook/img/18/36.png)

Соответственно, можем установить BPM ON WRITE на область, находящуюся ниже, где будет записан следующий символ.

![](.gitbook/img/18/37.png)

Отметим место, куда будет помещён следующий символ, а затем делаем RUN.

![](.gitbook/img/18/38.png)

Здесь записываю наиболее возможный серийный номер.

![](.gitbook/img/18/39.png)

Делаем RUN.

![](.gitbook/img/18/40.png)

И далее программа останавливается на том месте, где копируется неправильный серийный номер, и прежде, чем это произойдёт, можем установить на него BPM ON ACCESS, а затем выполнить RUN и снова остановиться точно на сравнении.

![](.gitbook/img/18/41.png)

Хорошо, думаю, что это был сложный случай, какой бы способ вы не избрали, так как место, в котором сохранялся серийник, постоянно менялось.

Ладно, оставляю домашнее упражнение – крэкми CrueHead’а 2 ***\[[ссылка](.gitbook/assets/files/18/CRACKME2.7z)\]***, а со следующей главы мы переходим к новой теме.

\[C\] Рикардо Нарваха, пер. Aquila
