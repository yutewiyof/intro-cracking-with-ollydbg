# Глава 29 - P-CODE. Часть 1

*(для запуска крэкми понадобиться MSVBVM50.dll **\[[ссылка](files/27/MSVBVM50.7z)\]**)*

Думаю, что в предыдущих главах мы рассмотрели все основные вещи относительно Visual Basic’а, а те, кто хочет изучить эту тему поглубже, могут прочитать посвящённые VB туториалы с cracklatinos *(на испанском – прим. пер.)*, которые укрепят и дополнят ваши знания.

Среди них встречаются очень хорошие туториалы о Visual Basic’е, написанные COCO, которые достаточно сложны и могут стать хорошей практикой, туториалы ARAMPUMK о волшебных точках Visual Basic’а, а также другие прекрасные туториалы, которые открывают дорогу для дальнейшего углубления в данную область. А мы меж тем перейдём к следующей теме, а именно к P-CODE.

Программы на Visual Basic’е могут быть двух типов: NATIVE, который мы рассматривали ранее, и P-CODE (псевдокод). Это то, что мы будем рассматривать в данной главе.

Основная разница заключается в том, что программы в NATIVE-коде выполняют строки кода в секции кода программы, в то время как если мы откроем программу, где используется P-CODE, в OllyDbg, модифицированном на предмет OEP’ов и VB, и установим BPM ON ACCESS в секции CODE, то увидим, что при выполнении не происходит остановок в секции кода, кроме тех случаев, когда встречается вызов какой-либо API-функции. Это очевидным образом указывает на то, что никакого исполняемого кода в данной секции нет.

Дизассемблирование программы, использующей P-CODE, ничем не поможет, так как там нет исполняемого кода. В ней всегда запускается DLL Visual Basic'а, которая читает значения из секции кода, указывающие ей, что нужно сделать. Например:

`1e делает Безусловный переход`

1e означает Безусловный переход. Он выполняется в DLL Visual Basic’а, то есть, то есть она считывает эти значения из секции кода, и они указывают DLL, что нужно сделать. Таким образом, никакого выполнения кода в соответствующей секции не происходит, только считываются из неё значения.

А сейчас, раз мы такие нахальные, то возьмём нож в руки и решительно атакуем то, за что ещё никто не брался: оттрасируем и интерпретируем действия, выполняемые крэкми с помощью псевдокода, и всё это в OllyDbg, опкод за опкодом, хе-хе.

Рассмотрим первый крэкми под названием clave1 ***\[[ссылка](files/29/clave1.7z)\]***, в котором необходимо найти серийный номер. Этот крэкми мы позаимствовали у нашего друга JB DUC’а, написавшего очень хорошие статьи по данной тематике.

Очевидно, что большая часть исследования P-CODE проводится с помощью прекрасного отладчика WKT. Если хотите почитать туториалы с его применением, то поищите те, что были написаны JB DUC’ом, а также в "Новом курсе" от CracksLatinos также есть превосходные статьи о P-CODE. Здесь мы будем использовать OllyDbg и EXDEC, который нам поможет видеть имена опкодов, так как Билл Гейтс не предоставил нам их список, хе.

![](img/29/1.png)

Здесь открываем крэкми в обычном, непропатченном, OllyDbg с установленными плагинами для его сокрытия, которые мы рассматривали в прошлых главах.

Поверхностный осмотр показывает, что как и в NATIVE-крэкми метод 4c может быть применён и здесь, и мы можем найти место, где находятся формы таким же образом, что и в NATIVE-приложениях (4c для снятия наг-окон отлично работает и в P-CODE, так что можно использовать именно этот метод, когда его возможно применить).

Что мы ещё видим?

Если пойдём вниз от точки входа, то не видим строк с кодом.

![](img/29/2.png)

Только мусор в подобном роде, поэтому не надо пытаться бессмысленно анализировать его, вспомним, что в NATIVE-приложениях на Visual Basic’е мы видели примерно то же самое, если спускали вниз от точки входа.

![](img/29/3.png)

Появляется мусор, но если продолжим дальше, то:

![](img/29/4.png)

Встречаем кусок кода довольно большого размера, который идёт до самого конца секции и представляющий собой исполняемый код вместо P-CODE, за исключением некоторых строк, которые, учитывая близлежащие байты, OllyDbg интерпретирует как инструкции, хотя на самом деле это тоже мусор.

Возвращаемся к крэкми с псевдокодом.

![](img/29/5.png)

Другая особенность – это API-функция под названием MethCallEngine, которую мы встречаем в крэкми, использующих псевдокод, так что теперь, когда нам нужно сделать первый шаг – определить, использует ли программа псевдокод или нет, то уже знаем, что нужно делать: надо посмотреть, есть ли исполняемый код в секции CODE или встречается ли там упомянутая нами функция.

Первое, что нам стоит сделать – это посмотреть, найдём ли мы какие-нибудь строки.

![](img/29/6.png)

![](img/29/7.png)

Это не слишком нам поможет, хотя, возможно, поможет что-нибудь другое.

Хорошо, установим BP прямо на JMP, который является прямым переходом к функции MethCallEngine,

![](img/29/8.png)

Ищем сверху от точки входа и быстро встречаем JMP на функцию MethCallEngine и, находясь прямо на этой строке, делаем правый клик мышью и выбираем FOLLOW, что приведёт нас прямо к данной функции, где и устанавливаем BP.

![](img/29/9.png)

![](img/29/10.png)

Теперь делаем RUN.

![](img/29/11.png)

Видим, что окно для ввода серийного номера появилось до остановки на вышеуказанной API-функции, что логично, так как создание окна и всё, что с этим связано, происходит таким же образом, как и в VB-приложениях, использующих "настоящий" код.

Теперь вводим ложный серийный номер.

![](img/29/12.png)

И нажимаем "REGISTRAR".

![](img/29/13.png)

Останавливаемся на JMP, который начинает истинную часть P-CODE.

![](img/29/14.png)

Здесь входим в API-функцию, посмотрим, что она будет делать.

![](img/29/15.png)

Здесь начинается.

Теперь, если откроем то же крэкми с помощью exdec ***\[[ссылка](files/29/exdec.7z)\]***, являющегося дизассемблером P-CODE, чтобы немного помочь себе, то увидим следующее:

![](img/29/16.png)

То есть первый байт, который будет прочтён – это 04, находящийся по адресу 401BD0. Он находится не очень далеко отсюда, так что установим на него BPM ON ACCESS.

![](img/29/17.png)

![](img/29/18.png)

![](img/29/19.png)

Этот первый байт, который будет прочтён. Когда остановимся, то окажемся в начале, и таким образом, мы можем оказаться там без помощи EXDEC. Как только остановимся на BP, установленном на API-функции MethCallEngine, мы можем поместить BPM ON ACCESS на секцию кода.

![](img/29/20.png)

И делаем RUN. Видим, что останов происходит несколько раз.

![](img/29/21.png)

Но только в одном из них происходит чтение содержимого ESI, в котором находится адрес, указывающий на вышеуказанный байт. Это место мы быстро находим после нескольких остановок (на моей машине их было точно 10).

![](img/29/22.png)

В первый раз, когда происходит останов и байт из \[ESI\] считывается и перемещается в AL – это то место, где начинается чтение первого опкода P-CODE. Данным образом можно найти первый байт, не используя EXDEC.

Как видим, последующие опкоды, которые отображаются EXDEC’ом идут вслед за предыдущим.

![](img/29/23.png)

![](img/29/24.png)

Как видим, порядок опкодов на обоих картинках соответствует друг другу. Между ними располагаются параметры, которые необходимы опкоду для выполнения.

![](img/29/25.png)

Как видим, здесь читается первый байт.

![](img/29/26.png)

На который, как видим, указывает ESI. На следующей строке никаких действий по выполнению опкода не предпринимается. Значение ESI увеличивается на 1, чтобы затем прочитать параметры опкода.

![](img/29/27.png)

Затем наконец доходим до косвенного JMP, который отправляет нас к строкам, выполняющим опкода, в данном случае это 04, как видим в EXDEC’е.

> 401BD0: 04 FLdRfVar                local\_008C

Видим, что такого загадочного делает этого опкод.

![](img/29/28.png)

Здесь видим выполнение опкода 04 FLdRfVar, это несколько маленьких строк кода, ничего такого, чтобы испугаться, хе-хе, и в конце видим, что заканчивается XOR EAX, EAX – это подготовка к чтению следующего опкода.

Первое, что делается – это берутся параметры опкода, которыми являются два байта, следующих за ним.

![](img/29/29.png)

Хорошо, они помещаются в EAX с помощью инструкции MOVSX, и значение FF74 является отрицательным (мы рассматривали это в главах, посвящённым ассемблеру). Продолжаем трассировать.

![](img/29/30.png)

Это значение в EAX равно -8c, и если кликнем по нему два раза:

![](img/29/31.png)

В окне показывается, что это значение равно -140 в десятеричной системе счисления или -8c в шестнадцатеричной. В EXDEX нам показывается 8c.

> 401BD0: 04 FLdRfVar                local\_008C

На следующей строке значение, считанное из параметров опкода, суммируется с EBP.

![](img/29/32.png)

И к этому значению применяется PUSH.

![](img/29/33.png)

То есть это эквивалент PUSH EBP-8c – выделение в стеке места для локальной переменной. На моей машине EBP равен 12f4e0, если отнимем 8c, то получится 12f454, то есть значение, которое останется в EAX и будет передано инструкции PUSH.

![](img/29/34.png)

![](img/29/35.png)

Ничего хорошего. Продолжаем.

![](img/29/36.png)

Видим, что далее в EAX помещается ноль, что означает завершение проводимых операций с данным опкодом и инициализацию регистров для чтения следующего. На следующей строке, действительно, читается следующий опкод.

![](img/29/37.png)

Второй опкод – это 21.

Видим его тут.

![](img/29/38.png)

![](img/29/39.png)

Как обычно, он помещается в AL.

![](img/29/40.png)

А теперь к значению в ESI прибавляется 3, чтобы регистр указывал на параметры опкода. Затем управление переходит к косвенному JMP, который ведёт на опкод 21.

Посмотрим, что нам скажет гугл.

> '21, FLdPrThis
> (Загрузить ссылочный указатель в указатель на элемент данных.)

Хорошо, у нас здесь несколько указателей, про которые мы не знаем, для чего они служат, но примерно дело состоит в том, что берётся ссылочный указатель и загружается в указатель на элемент данных. В ассемблере это было бы чтение указателя из стека и загрузка его в другое место стека же.

Если продолжим трассировать:

![](img/29/41.png)

Видим, что читается содержимое EBP+8 (ссылочный указатель) и сохраняется в EBP-4c (указатель на элемент данных).

Хорошо, прочитанное значение на моей машине равно 15b000. Если посмотрим в DUMP’е:

![](img/29/42.png)

![](img/29/43.png)

Видим, что здесь находится указатель на 4022e8, а если посмотрим в DUMP, то увидим:

![](img/29/44.png)

Видим, что здесь начинается таблица, так что 15b000 – это ссылочный указатель, указывающий на что-то, что находится в таблице, хотя это не очень поможет нам для крэкинга, всегда хорошо постараться расшифровать, что происходит в программе.

В остальном, это команда без параметров, поэтому никаких вариаций у неё нет. При исполнении она всегда читает ссылочный указатель и сохраняет его в указатель на элемент данных.

Хорошо, продолжаем.

![](img/29/45.png)

Далее обнуляется EAX, а на следующей строке читается третий опкод.

![](img/29/46.png)

Смотрим в EXDEC, что такое 0F.

![](img/29/47.png)

`VcallAd`

![](img/29/48.png)

Ок, здесь видим, в чём заключается смысл опкода 0F, видим, что у него один параметр из двух байтов.

![](img/29/49.png)

Параметр в моём случае – это 0300, и он указывает смещение в таблице дескрипторов элементов данных. Хм, видим, что доходим до косвенного JMP, посмотрим, совпадёт ли это с тем, что говорится.

![](img/29/50.png)

Здесь читается содержимое EBP-4c и помещается в EBX.

![](img/29/51.png)

Здесь располагается указанное значение 15b000. Оно помещается в стек.

![](img/29/52.png)

![](img/29/53.png)

Затем читаем параметры. В моём случае, это 300.

![](img/29/54.png)

![](img/29/55.png)

Суть дела состоит в том, что содержимое EBX, равное 15b000, это начало таблички, которую мы ищем, то есть таблица дескрипторов элементов данных. Адрес – 4022e8.

![](img/29/56.png)

И к этом прибавляем 300, то есть смещение до адреса, где начинается искомое значение.

![](img/29/57.png)

Таким образом, прибавив к началу таблицы 300, получим в EAX значение 4025e8.

![](img/29/58.png)

Это значение указывает сюда:

![](img/29/59.png)

То есть опкод 0f, используя предоставленный параметр, получает сохранённое в таблице значение.

![](img/29/60.png)

Дальше у нас вызов по адресу, где читается данная таблица, и как видим, содержимое EAX равно:

![](img/29/61.png)

Заходить в CALL не будем, сразу посмотрим, что останется у нас при выходе из него. Как уже говорилось, значения сохраняются в стек.

Продолжаем трассировать, проходим CALL с F8.

![](img/29/62.png)

![](img/29/63.png)

То есть после всего этого в стеке остаётся значение, и нам необходимо выяснить, для чего оно служит. Пока что мы знаем, что это значение читается из таблицы элементов данных, параметр равен 0300, и результат кладётся в стек.

![](img/29/64.png)

Следующий опкод равен 19, он работает с локальной переменной 88, которая становится источником его параметра.

![](img/29/65.png)

Здесь выходим из его выполнения.

![](img/29/66.png)

Что у нас тут?

![](img/29/67.png)

С помощью MOVSX считываются параметры, отрицательные значения дополняются FF.

![](img/29/68.png)

Как уже предсказывалось ранее, это значение -88 в шестнадцатеричной системе счисления, о чём нам говорит EXDEC.

![](img/29/69.png)

\-136 в десятеричной равной -88 в шестнадцатеричной.

![](img/29/70.png)

Здесь увеличиваем указатель ESI на два и складываем EBP с -88, и результат этой операции помещается в EAX.

![](img/29/71.png)

![](img/29/72.png)

Видим, что к тому моменту, когда доходим до вызова, в стеке находятся три параметра.

![](img/29/73.png)

Первым является значение, которое было сохранено предыдущим опкодом, а два других значения в моём случае равны 12f458 (локальная переменная ebp-88) и -1 – третий параметр. Нажимаем F8, чтобы не заходить внутрь вызова.

После его выполнения видим, что в ebp-88 сохранилось значение, найденное предыдущим опкодом.

![](img/29/74.png)

Всё остальное осталось таким же, не считая изменений в стеке и того, что ECX возвратил 0, вероятно для того, чтобы отметить, что процесс был завершён.

То есть то, что было помещено в EBP-88 – это значение, полученное предыдущим опкодом.

![](img/29/75.png)

Доходим до другого опкода, равного 08, которая также пытается работать с той же локальной переменной 88, то есть ebp-88.

![](img/29/76.png)

Входим в опкод.

![](img/29/77.png)

В куске кода, видим `XOR EAX, EAX`, завершающий выполнение опкода, а чуть выше – условный переход. Посмотрим, что он делает.

Сначала EAX’у передаются параметры опкода.

![](img/29/78.png)

Как и в прошлый раз, значение FF78, перемещённое с помощью MOVSX, имеет FFы в своём составе, то есть это отрицательное число, равное -88 в шестнадцатеричной системе.

![](img/29/79.png)

![](img/29/80.png)

На это строке напрямую задаётся сумма EAX+EBP, то есть EBP-88, и перемещается значение, содержащееся по данному адресу. Очевидно, что мы берём его из таблицы элементов данных.

![](img/29/81.png)

![](img/29/82.png)

Тестируем, равно ли нулю, если бы так и было, то переход был бы совершён, но так как сейчас нуля нет, то продолжаем.

![](img/29/83.png)

Сохраняем это значение в EBP-4C.

Здесь нам нужно вспомнить то, о чём говорилось в самом начале.

То, что мы видим – это чтение содержимого EBP + 8 (ссылочный указатель) и сохранение оного в EBP.

Так как ebp-4с – это указатель на элемент данных, и мы уже убедились, что он содержит корректное значение и в нём нет нуля, то поэтому эта переменная ebp-4c называется "указатель на элемент данных", так как это значение связано с таблицей элементов данных.

![](img/29/84.png)

Доходим до следующего опкода.

![](img/29/85.png)

![](img/29/86.png)

В пресвятом Гугле смотрим, для чего служит этот опкод.

0d VCallHresult #получает текст из поля ввода текста (textbox)

То есть будет прочитан неправильный серийный номер, который мы ввели в текстовое поле. Трассируем и смотрим, так ли это.

![](img/29/87.png)

Видим опкод, завершающийся `XOR EAX, EAX` как обычно.

Первое, что здесь происходит – это считывается содержимое из EBP-4c (а это, как мы говорили, указатель на элемент данных) и помещается в EAX. Это архизнакомое нам значение, считывающееся из таблицы элементов данных.

![](img/29/88.png)

Дальше это значение помещается в стек.

![](img/29/89.png)

Потом считывается параметр опкода.

![](img/29/90.png)

![](img/29/91.png)

![](img/29/92.png)

И помещается в EDI.

Затем читается содержимое EAX, являющееся началом другой таблицы.

![](img/29/93.png)

![](img/29/94.png)

И к этому значению прибавляется параметр 00a0, чтобы получить окончательный адрес в её пределах.

![](img/29/95.png)

![](img/29/96.png)

И затем совершается CALL по адресу в этой таблице. Конечно, не будет трассировать этот вызов, посмотрим на то, какие значения останутся в стеке от выполнившихся опкодов.

![](img/29/97.png)

Выполняем CALL с помощью F8.

Затем помещаем в EDX значение из EBP-44.

![](img/29/98.png)

![](img/29/99.png)

И после сравнения пары значений доходим до следующего опкода, но вы можете спросит, читает ли он то, что мы ввели, то есть наш неправильный опкод? Смотрим ответ на этот вопрос в EXDEC.

![](img/29/100.png)

Видим, что продолжается работа с локальной переменной 8c, которую мы также знаем как EBP-8C.

Если поищем значение EBP-8c:

![](img/29/101.png)

Оно равно 12f454.

![](img/29/102.png)

И это указатель на введенный нами неправильный серийный номер, который находится в 15d3bc.

![](img/29/103.png)

Уф, пришлось попотеть, но мы, наконец, добрались до того места, где считывается неправильный серийник.

Следующий опкод – это 6c IldRf

![](img/29/104.png)

![](img/29/105.png)

![](img/29/106.png)

Здесь говорится, что этот опкод занимается загрузкой ссылочного значения. Заходим в него.

![](img/29/107.png)

Что у нас здесь?

![](img/29/108.png)

Сначала осуществляется перемещение параметра с помощью MOVSX, который является отрицательным (FF).

![](img/29/109.png)

Смотрим, что у нас оказывается в EAX.

![](img/29/110.png)

Это -8c в шестнадцатеричной системе.

![](img/29/111.png)

Следующая инструкция суммирует его с EBP, что в результате даёт EBP-8c. Содержимое по этому адресу кладётся в стек.

![](img/29/112.png)

Содержимое ebp-8c – это указатель на неправильный серийник, то есть сейчас этот указатель находится у нас в стеке.

![](img/29/113.png)

Если посмотрим через DUMP, то ясно увидим, что он указывает на неправильный серийный номер. Таким образом, это и является действием опкода загрузки ссылочного значения, который кладёт в стек значение из локальной переменной.

Следующий опкод – это:

1b LitStr , что расшифровывается как "Literal String" (символьная строка)

Смотрим, что он делает.

![](img/29/114.png)

Входим в опкод.

![](img/29/115.png)

Сначала читается параметр, который здесь равен 0001 (положительный, т.к. нет FF). Он помещается в EAX.

![](img/29/116.png)

![](img/29/117.png)

Видим, что на следующей строке в EDX помещается значение 4017E4. Для чего оно, мы не знаем.

![](img/29/118.png)

И для чего может служить помещение в стек 4016f8?

![](img/29/119.png)

Видим, что в пояснении EXDEC’а показываются только две одинарные кавычки, то есть значение, помещаемое в стек, является пустой строкой.

![](img/29/120.png)

Конечно же, смотрим через DUMP, что указывает на пустую строку, заключённую в кавычки, то есть то, с чем будет работать следующий опкод, проверяющий, напечатали мы что-нибудь или оставили поле ввода пустым и нажали "Register".

![](img/29/121.png)

Что есть:

![](img/29/122.png)

Ок, "LEAD 0" – это операция, а "30 EqStr" – это вторая часть опкода. Посмотрим, что это такое в пресвятом Гугле.

Lead0/30 EqStr – сравнение двух строк.

То есть здесь будут сравниваться эти две строки. Это двойной опкод, то есть сначала считывается то, что в дальнейшем будет использоваться для косвенного перехода.

![](img/29/123.png)

И здесь первый опкод завершается "XOR EAX, EAX", где ничего не делается, и читается второй опкод.

![](img/29/124.png)

![](img/29/125.png)

Здесь читается второй опкод 30, но разница в случае с двойным опкодом заключается в считывании параметров, так как в таком опкоде первый завершается с помощью "XOR EAX, EAX" и считывается второй, но параметры первого опкода остаются доступными для чтения.

![](img/29/126.png)

Здесь находится второй опкод, который делает PUSH 0.

![](img/29/127.png)

Когда доходим до CALL’а, у нас есть три аргумента. Минуем CALL с помощью F8 и смотрим, что изменилось.

Видим, что стек сместился, но значения остались без изменений, только находятся теперь чуть выше.

Следующая строка "CMP AL, 0" сообщает, что здесь в AL сохраняется результат. В моём случае это:

![](img/29/128.png)

AL=01

Потому что строки не равны.

![](img/29/129.png)

После сравнения в EAX помещается значение ноль, а в конечном итоге это значение помещается в стек, так как это результат опкода. Ноль, если не равны, а если бы были равно, то вместо ноля было бы FFFFFF. Можете проверить, хе-хе.

![](img/29/130.png)

Доходим до следующего опкода.

![](img/29/131.png)

Пресвятой Гугл сообщает нам, что это примерно то же, что и SysFreeString, которая освобждает память, занятую неиспользуемой строкой. Видим, что в данном случае освободится ebp-8c.

![](img/29/132.png)

Видим, что в EDI перемещается значение 1, затем в EBX – FF74 (в шестнадцатеричной системе это -8c). Как обычно, используется MOVSX, чтобы перемещать вместе с FF’ами, если значение отрицательно.

![](img/29/133.png)

![](img/29/134.png)

EBX+EBP равно EBP-8c, так что в стек помещается указатель на неправильный серийный номер.

![](img/29/135.png)

![](img/29/136.png)

Видим, что идёт вызов API-функции SysFreeString, а по возвращению из неё:

![](img/29/137.png)

Указатель на наш неправильный серийный номер был заменён на нули.

![](img/29/138.png)

Сам неправильный серийник не был стёрт, он как был, так и остаётся по адресу 15d3bc. Был стёрт указатель на него, находившийся в EBP-8c.

![](img/29/139.png)

Доходим до следующего опкода.

![](img/29/140.png)

Это сотрёт содёржимое локальной переменной ebp-88.

А что там находится?

![](img/29/141.png)

![](img/29/142.png)

Ах, это значение, которое мы искали в таблице элементов данных.

![](img/29/143.png)

Здесь смотрим параметры опкода:

![](img/29/144.png)

FF78, который является шестнадцатеричным значением -88.

![](img/29/145.png)

Далее в EAX помещается содержимое EBP-88, проверяется, равно ли оно нулю, так как оно не равно, то продолжаем дальше.

![](img/29/146.png)

И доходим до вызова, который, как и раньше, освобождает это значение, и стирает содержимое ebp-88.

![](img/29/147.png)

Здесь помещаем в EAX ноль.

![](img/29/148.png)

Следующий опкод – это:

![](img/29/149.png)\-

Это условный переход, так как все BRANCH’и – это переходы.

![](img/29/150.png)

То есть это переход, срабатывающий, если результат равен "лжи", а затем идёт JMP, то есть этот переход, если мы что-то вводим в поле ввода, переходит на проверку серийного номера, а если нет, то процесс будет повторён, используя JMP.

Видим, что это так, если будет переход, то следующим опкодом станет:

![](img/29/151.png)

Так как это условный переход, избегаем JMP в 401bf3.

![](img/29/152.png)

Здесь опкод завершается и читается следующий.

![](img/29/153.png)

Как можно предположить из FE в 401bfg6, условный переход срабатывает и минут JMP, хе-хе.

Lead3/c1 LitVarI4

Это двойной опкод. Посмотрим, что он делает.

![](img/29/154.png)

Здесь завершается первый опкод и читается второй.

![](img/29/155.png)

Который начинается здесь. Терпеливо трассируем его.

![](img/29/156.png)

Считываются параметры опкода.

![](img/29/157.png)

Уже знаем, что они дополянются FF, если содержат отрицательное значение, как в данном случае.

![](img/29/158.png)

Параметры считываются дальше, в данном случае это целый DWORD, который помещается в EAX.

![](img/29/159.png)

![](img/29/160.png)

И это значение сохраняется в локальную переменную.

![](img/29/161.png)

EBP+ FFFFFF54 + 8, то есть сумма первого параметра и 8 даёт 12f43c, а здесь это значение сохранено.

![](img/29/162.png)

![](img/29/163.png)

JMP помещает нас в:

![](img/29/164.png)

Где 12f434 помещается в стек.

![](img/29/165.png)

Это указатель на структуру, начинающуюся с 3, которое уже было сохранено, а чуть пониже – сохранённое значение.

![](img/29/166.png)

Продолжаем.

В случае, если серийный номер здесь жёстко задано, можем попробовать передать это значение в десятеричном виде и посмотреть, не является ли он правильным серийным номером. Откроем другой экземпляр крэкми не из-под OllyDbg.

![](img/29/167.png)

Посмотрим в OllyDbg, чему равно это число в десятеричной системе.

![](img/29/168.png)

Оно равно 246810. Введём его в крэкми.

![](img/29/169.png)

![](img/29/170.png)

Хе-хе, я подозревал это, но так легко нам не отделаться. Доходим до сравнения.

![](img/29/171.png)

Следующий опкод также двойной.

Это FC и немедленно он завершается и начинается второй.

![](img/29/172.png)

![](img/29/173.png)

Это F6, бесстрашно заходим в него, EXDEC нам говорит, что будем работать с локальной переменной 9c (то есть ebp-9c).

![](img/29/174.png)

Здесь читаются параметры, которые дополнены FF.

![](img/29/175.png)

Конечно, это значение -9c.

![](img/29/176.png)

Прибавляем к EBP, чтобы получилось EBP-9c или 12f444, которое пока что остаётся пустым.

![](img/29/177.png)

![](img/29/178.png)

![](img/29/179.png)

Затем проводится проверка, равно ли это значение 8, если да, то делаем переход.

![](img/29/180.png)

Далее снова переход, но не будет вдаваться в детали. Доходим до последних строк опкода.

![](img/29/181.png)

![](img/29/182.png)

Помещаем значение 3, находящееся в EAX в переменную EBP-9c

И стираем 3 из структуры, встреченной нами ранее.

![](img/29/183.png)

При выполнении:

![](img/29/184.png)

Затем последующие строки копируют всё, что у нас здесь есть в новое местоположение, то есть в EBP-9c.

![](img/29/185.png)

Здесь видим число, которое является правильным серийным номером и находящееся в структуре, начинающейся в EBP-9c.

![](img/29/186.png)

Доходим до следующего опкода.

> 401C02: 04 FLdRfVar                local\_008C

Видим, что повторяется всё, что мы уже видели в начале.

> 401C02: 04 FLdRfVar                local\_008C
>
> 401C05: 21 FLdPrThis
>
> 401C06: 0f VCallAd                 text
>
> 401C09: 19 FStAdFunc               local\_0088
>
> 401C0C: 08 FLdPr                   local\_0088
>
> 401C0F: 0d VCallHresult            get\_\_ipropTEXTEDIT
>
> 401C14: 6c ILdRf                   local\_008C
>

Всё похоже на то, как было в начале. Следующий опкод:

![](img/29/187.png)

Поэтому, чтобы перепрыгнуть через всё, что уже было, устанавливаем BPM ON ACCESS на 401c17, чтобы остановиться на считывании опкода.

![](img/29/188.png)

Останавливаемся здесь и читаем опкод 0A. Смотрим, что это такое в EXDEC’е.

Это ImpAdCallFPR4 – вызов API-функции. EXDEC показывает какой именно.

Например:

![](img/29/189.png)

В данном примере произойдёт вызов API-функции rtcMsgBox. В нашем же случае это вызов функции:

401C17: 0a ImpAdCallFPR4: \_rtcR8ValFromBstr

![](img/29/190.png)

Читаются параметры опкода.

![](img/29/191.png)

![](img/29/192.png)

Они помещаются в ECX.

![](img/29/193.png)

Затем в EAX помещается значение 401000 и тестируется, не равно ли оно нулю.

![](img/29/194.png)

Далее читается второй параметр.

![](img/29/195.png)

![](img/29/196.png)

![](img/29/197.png)

И доходим до "CALL EAX", где EAX равен 401000. Смотрим, куда это ведёт – а ведёт это к упомянутой выше API-функции.

![](img/29/198.png)

Параметр, передающийся через стек API-фукнкции:

![](img/29/199.png)

Мой неправильный серийный номер:

![](img/29/200.png)

Который был загружен в St0, являющаяся верхним элементом стека плавающей запятой. Мы не говорили об этом раньше, но ничего. Находятся эти элементы под регистрами, если у вас они не отображаются, то нужно использовать специальную опцию. Нажимаем правую кнопку мыши.

![](img/29/201.png)

Здесь загружается мой неправильный серийный номер.

![](img/29/202.png)

Доходим до следующего опкода.

401C1C: Lead2/6b CVarR8

Итак, находимся здесь, заходим в опкод.

![](img/29/203.png)

Так как опкод двойной, то завершается первый и грузится второй.

![](img/29/204.png)

Ок, здесь несколько инструкций плавающей запятой, которые мы не рассматривали.

Но видим, что вначале загружаются параметры.

![](img/29/205.png)

В данном случае:

![](img/29/206.png)

![](img/29/207.png)

Суммируются с EBP, и в EAX остаётся:

![](img/29/208.png)

![](img/29/209.png)

FSTP сохраняет первое первое значение из стека плавающей запятой, то есть из ST(0), в указанную ячейку памяти (в данном случае \[EAX+8\], то есть 12f43c) и делает следующий элемент стека верхним. Ок, мы рассмотрим это позже.

![](img/29/210.png)

После выполнения:

![](img/29/211.png)

Я уже знаю, что у вас могут зародиться кое-какие подозрения о том, что это наш серийный номер, сконвертированный в 64-х битное число. Посмотрим, так ли это, кликнув на правую кнопку мыши.

![](img/29/212.png)

![](img/29/213.png)

Видим, что действительно это неправильный серийный номер, но только в другом представлении – 8 байтов, то есть 64-битном. Логично, раз 4 байта – это 32 бита, то двойное слово состоит из 64-х бит и выглядит по другому.

![](img/29/214.png)

Включаем обратно обычный режим представления.

![](img/29/215.png)

Эта инструкция сохраняет значение регистра SR (регистр состояния FPU) в AX. Выполняем:

![](img/29/216.png)

![](img/29/217.png)

Здесь опкод завершается.

> 401C20: 5d HardType

Ок, у меня нет ни малейшей идеи, что это такое, но попытаемся это выяснить.

![](img/29/218.png)

Ок, всего лишь две строки, которые грузят содержимое ESP в EAX.

![](img/29/219.png)

![](img/29/220.png)

Видим, что там находится число, находящееся чуть выше моего трансформированного фальшивого серийного номера. Возможно, что это число указывает, в каком формате он хранится.

![](img/29/221.png)

Следующий опкод.

> 401C21: 04 FLdRfVar                local\_009C

То есть PUSH ebp-9c, в данном случае:

![](img/29/222.png)

![](img/29/223.png)

Далее идёт двойной опкод.

> 401C24: Lead0/40 NeVarBool

![](img/29/224.png)

Здесь читается второй опкод.

![](img/29/225.png)

Доходим до вызова, а параметры в стеке следующие:

![](img/29/226.png)

Один – это указатель на правильный серийный номер, другой – на трансформированный неправильный. Будет их сравнение?

![](img/29/227.png)

![](img/29/228.png)

![](img/29/229.png)

Устанавливаем BP сюда.

![](img/29/230.png)

Видим, что после выхода из call’а EAX содержит 1.

![](img/29/231.png)

И поскольку делается PUSH значения FFFFFFFF в стек, то можно практически безошибочно предположить, что именно здесь проводится сравнение, так что рестартуем крэкми, установив BP, и вводим правильный серийный номер, который был получен из этого сравнения.

![](img/29/232.png)

03c41a в десятеричной системе – это 246810. Вводим его и снова идём к сравнению.

![](img/29/233.png)

Остановившись, видим, что происходит сравнение:

![](img/29/234.png)

246810 со прежним шестнадцатеричным значением. Дело в том, что они в разных форматах, но сверху каждого из них есть число, указывающее, в каком именно хранится значение, поэтому возможно, что внутри каждого call’а они будут трансформированы и сравнены. Смотрим, что у нас получится в результате.

![](img/29/235.png)

Видим, что теперь у нас EAX = 0 (раньше было 1).

![](img/29/236.png)

И в стек также уходит ноль.

Это означает, что это и есть сравнение, к тому же прямо внизу видим несколько Branch’ей, которые совершают переход в зависимости от того, окошко с каким сообщением надо показать, а потом идёт освобождение строк и использованных значений.

![](img/29/237.png)

Вы можете сказать, что было слишком много работы, но это был первый раз, поэтому мы подробно рассматривали каждый опкод, и это необязательно повторять в будущем. Отладчик WKT может показать вам имена опкодов. Вы не знаете, что делает каждый из них, но с помощью OllyDbg можете определить, для чего они служат, и получить представление о том, как работает программа.

В следующей части мы рассмотрим крэкми "clave 2" ***\[[ссылка](files/29/clave2.7z)\]***, используя тот же метод. Мне бы хотелось, чтобы вы попробовали самостоятельно его сделать, но если не получится, то в следующей части вы сможете прочитать решение этого крэкми.

\[C\] Рикардо Нарваха, пер. Aquila
