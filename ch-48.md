# Глава 48 - Распаковка PeSpin v1.3.04f. Часть 1

Если вы загрузили главы 46 и 47 сразу после их появления, то, возможно, не читали добавленное к ним позднее примечание:

>После того, как была написана 46 глава и еще не было завершено решение Patrick’а, я заметил, что эти туториалы слишком сложны для уровня, до которого мы дошли, так что если вам главы 46 и 47 покажутся очень сложными, то советую оставить их до тех времен, когда вы будете более подготовлены, а сейчас сразу перейти к 48 главе, соответствующей тому уровню, на котором мы остановились.
>
>***Рикардо Нарваха***

Так уж вышло, что когда я занялся Patrick’ом, то сначала решил его простым методом (упомянутым в конце 47-й главы) и посчитал, что он легок до неприличия. Как следствие, данные главы оказались труднее прежних и пришлось добавить процитированное выше примечание.

В этой главе мы рассмотрим упаковщик PeSpin 1.304 Full ***\[[ссылка](UnPackMe_PeSpin1.3.04.f.7z)\]***, о котором уже существуют достаточно хорошие туториалы. На самом деле, написать еще не существующий туториал практически невозможно, так как ресурс CracksLatinoS содержит очень хорошие статьи почти обо всех упаковщиках.

В PeSpin дойти до OEP очень просто.

![](.gitbook/img/48/1.png)

Сейчас анпэкми остановлен на его EP. Мы будем пользоваться Parcheado 5 ***\[[ссылка](.gitbook/assets/files/26/olly_parcheado_para_vb.7z)\]*** — версией OllyDbg, которая предназначена для поиска OEP’ов.

![](.gitbook/img/48/3.png)

Открыв карту памяти, установим MEMORY BREAKPOINT ON ACCESS в первой секции после заголовка. Этот брейк равнозначен ON EXECUTION, поскольку, как помните, пропатченная для поиска OEP’ов версия отладчика в данном случае останавливается только при выполнении, а не при чтении или записи.

![](.gitbook/img/48/5.png)

Следует убедиться, что все галки во вкладке Exceptions окна Debugging options установлены:

![](.gitbook/img/48/7.png)

После нажатия на RUN можно пойти спокойно пить кофе:

![](.gitbook/img/48/9.png)

Как следует напившись кофе, хе-хе, обнаружим, что остановка произошла на непохожем на OEP месте, а значит, от команд исходной OEP ничего не осталось из-за украденных байтов:

![](.gitbook/img/48/11.png)

Посмотрим стек:

![](.gitbook/img/48/13.png)

Можно заметить, что перед прибытием в ложную OEP было выполнено много кода, и это свидетельствует о том, что байты OEP были украдены.

![](.gitbook/img/48/15.png)

Кроме того, если сделаем Search for –> All intermodular calls, то найдем очень мало вызовов API-функций:

![](.gitbook/img/48/17.png)

Посмотрим один из них:

![](.gitbook/img/48/19.png)

![](.gitbook/img/48/21.png)

Дойдя до косвенных переходов на API-функции, заглянем в IAT:

![](.gitbook/img/48/23.png)

Здесь виден конец IAT’а — 460F28. Теперь поднимемся выше:

![](.gitbook/img/48/25.png)

Похоже, это переадресовочные элементы. Чтобы проверить, принадлежат ли они IAT’у, посмотрим их референсы:

![](.gitbook/img/48/27.png)

Поиск ничего не дает, но если подняться еще выше, то станет ясно, что это всё-таки часть IAT’а. Таким образом, в PeSpin используется и переадресация.

![](.gitbook/img/48/29.png)

Начало IAT’а находится по адресу 460818. Мы еще вернемся к этому месту, когда будем исправлять IAT, а сейчас займемся возвращением украденных байтов; чуть выше ложной OEP для них как раз есть подходящая нулевая область:

![](.gitbook/img/48/31.png)

Перезагрузим программу и посмотрим состояние стека:

![](.gitbook/img/48/33.png)

Здесь видно, что перед запуском анпэкми адрес вершины стека равен 12FFC4 (так на моем компьютере). Это означает, что при прибытии к истинной OEP вершина стека должна находиться по тому же адресу, то есть в 12FFC4. Обычно первой командой программы является PUSH EBP, которая записывает значение в следующую ячейку стека (12FFC0), поэтому найдем ее в дампе и установим на ней HARDWARE BPX ON WRITE. Такое рассуждение логично, но оно может и не дать результатов, если упаковщик обнаруживает аппаратные брейкпоинты или, для осложнения поиска OEP, меняет адреса стека.

![](.gitbook/img/48/35.png)

После установки брейка нажмем RUN:

![](.gitbook/img/48/37.png)

Первая остановка произошла здесь, но данная инструкция скорее всего принадлежит распаковщику. Нажмем F9 еще раз:

![](.gitbook/img/48/39.png)

Теперь остановились на PUSH EBP, что весьма похоже на команду из OEP. Чтобы проверить это предположение, воспользуемся, хе-хе, трассировкой. Конечно же, JMP’ы нас не интересуют, так как они не влияют на состояние регистров или стека.

![](.gitbook/img/48/41.png)

![](.gitbook/img/48/43.png)

![](.gitbook/img/48/45.png)

Здесь встречается необычная комбинация команд: сначала выполняется PUSH, а затем только что записанное в стек значение суммируется с константой:

![](.gitbook/img/48/47.png)

После выполнения инструкции ADD значение в стеке оказывается 450E60, поэтому данная комбинация равнозначна PUSH 450E60.

![](.gitbook/img/48/49.png)

Затем этот трюк повторяется, но уже вместо PUSH 4292C8:

![](.gitbook/img/48/51.png)

Далее идет еще одна подходящая инструкция:

![](.gitbook/img/48/53.png)

И еще парочка:

![](.gitbook/img/48/55.png)

![](.gitbook/img/48/57.png)

Продолжим:

![](.gitbook/img/48/59.png)

![](.gitbook/img/48/61.png)

![](.gitbook/img/48/63.png)

![](.gitbook/img/48/65.png)

![](.gitbook/img/48/67.png)

![](.gitbook/img/48/69.png)

Сейчас мы просто скопируем этот CALL, а потом, при восстановлении IAT’а, посмотрим, относится ли он к какой-нибудь API-функции.

![](.gitbook/img/48/71.png)

![](.gitbook/img/48/73.png)

![](.gitbook/img/48/75.png)

![](.gitbook/img/48/77.png)

![](.gitbook/img/48/79.png)

![](.gitbook/img/48/81.png)

![](.gitbook/img/48/83.png)

![](.gitbook/img/48/85.png)

Переход на ложную OEP завершает трассировку, а мы тем временем узнали список украденных байтов, хе-хе.

![](.gitbook/img/48/87.png)

Скопируем их в область OEP:

![](.gitbook/img/48/89.png)

Они байт-в-байт заполнили нулевую область, так что теперь украденные байты возвращены, хотя мы даже не приступали к сдампливанию. В следующей главе мы будем разбираться с IAT’ом.

До встречи в 49-й главе!

\[C\] Рикардо Нарваха, 17.07.06 пер. Рома Стремилов, 01.2010
