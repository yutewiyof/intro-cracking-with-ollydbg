# Глава 36 - Переадресовочные элементы IAT

Продолжаем, очень плавно повышая сложность изучаемых упаковщиков. В этой главе мы рассмотрим два распакуй-меня – crunch (или bitatrs 5.0) и telock 0.98, которые послужат нам для освоения темы переадресовочных элемент IAT. Оба распакуй-меня приложены к данному туториалу, поэтому у вас не должно быть проблем, где их взять.

Начнём с самого простого – с BITARTS [\[ссылка\]](.gitbook/assets/files/32/bitarts_evaluation.c.7z). Загрузим его в OllyDbg.

![](.gitbook/img/36/1.png)

Видим, что начального PUSHAD нет, так что потрассируем немного с помощью F7.

![](.gitbook/img/36/2.png)

Доходим до PUSHAD, проходим его с помощью F7 и делаем ESP – FOLLOW IN DUMP.

![](.gitbook/img/36/3.png)

И устанавливаем точку аппаратного останова (hardware breakpoint) на доступ к первым байтам.

![](.gitbook/img/36/4.png)

Теперь нажимаем F9 и после прохода через другое исключение останавливаемся на точке аппаратного останова.

![](.gitbook/img/36/5.png)

Трассируем строки дальше и оказываемся в OEP.

![](.gitbook/img/36/6.png)

Также оказаться в OEP можно с помощью поисковика OEP OllyDbg, если последняя пропатчена для этого, или почти любым другим методом, рассмотренным в предыдущих главах "Введения…".

Как видим, указанный адрес находится в первой секции после заголовка.

![](.gitbook/img/36/7.png)

Поэтому кажется, что всё в порядке, включая отмеченную секцию CODE, так что проблем не должно быть.

![](.gitbook/img/36/8.png)

Видим, что в данном случае первая вызываемая API-функция – это GetVersion, поэтому также устанавливаем на данную API-функцию BP, и когда останавливаемся при вызове её из первой секции, то по возвращению мы оказываемся в области OEP.

Ок, OEP не представляет секрета, и теперь заглянем в IAT. Конечно, рассматриваемый нами вызов выглядит как прямой, но легко убедиться, что, на самом деле, он косвенный: загружается правильный для моей машины адрес API-функции GetVersion для того, чтобы совершить на него переход.

Значит, 460ADC – это элемент IAT, соответствующий GetVersion. Идём в DUMP и сверяемся с IAT.

![](.gitbook/img/36/9.png)

Она довольно большая, хе-хе.

![](.gitbook/img/36/10.png)

Первый элемент в IAT – это GetVersion, который соответствует Kernel32.dll, можно посмотреть в карте памяти, куда ведёт указанный адрес 7Cxxxxxx.

![](.gitbook/img/36/11.png)

Видим, что всё соответствует Kernel32.dll, рядом с серединой, как и в прошлой части, есть пара смещений, соответствующих ntdll, но мы уже проверили, что система выдаёт исключения для этих API-функций, которые изначально относились к kernel32.dll и были заменены на похожие из ntdll.dll, но для совместимости они считаются системой вызываемыми из kernel32.dll без каких-либо проблем. В любом другом случае система не станет делать исключений, и API-функции должны относиться к соответствующей DLL, которые, в свою очередь, должны быть отделены нулями, как того требует правильно составленная IAT.

Хорошо, после этого спускаем ниже и находим группу API-функций с адресами вида 77xxxxxx.

Если есть какие-то сомнения относительно того, к какой DLL принадлежит элемент, то кроме анализа карты памяти, можно отметить его в IAT, нажать правую кнопку мыши и выбрать FIND REFERENCES.

![](.gitbook/img/36/12.png)

Так что ищем в списке все инструкции, использующие данный элемент (это будет работать всегда: и когда список показывает секцию программы, где собственно выполняется работа, в данном случае первая секцию, если будем искать в ней ссылки, и в списке, отображающем другую секцию, поищем в ней, вероятно, что ничего не найдём, так что нужно проверять перед использованием данного метода, находимся ли мы в правильной секции, где исполняется распакованная программа, или рядом с областью OEP, что одно и то же),

![](.gitbook/img/36/13.png)

Здесь видимы CALL’ы, которые есть в первой секции и соответствующие указанному элементу. Та, которая относится к API-функции VariatClear из OleAut32.dll:

![](.gitbook/img/36/14.png)

Смотрим в карте памяти, видим, что, конечно, следующая группа попадает в секцию кода OleAut32.dll.

![](.gitbook/img/36/15.png)

Если продолжим спускаться без указания каждой DLL, то увидим группы элементов, ведущие в другие элементы, разделение нулями, другую группу, следующее разделение, и так пока не дойдём до самого конца этой IAT-схемы.

![](.gitbook/img/36/16.png)

Здесь видим завершающую часть, лазурным цветом выделена группа API-функций, соответствующих некой DLL, затем – разделение, затем розовым цветом обозначена другая группа, разделение, а после – элемент, отмеченный стрелкой и ещё одно разделение, после которого привычная схема IAT уже не соблюдается. Мы можем проверить, является ли отмеченный стрелкой элемент ссылкой на API-функцию. Это можно сделать двумя способами.

![](.gitbook/img/36/17.png)

![](.gitbook/img/36/18.png)

Видим, что есть элемент IAT, который приводит нас в данном случае к OleUiBusyA из oledlg.dll. Проверим через карту памяти.

![](.gitbook/img/36/19.png)

Логично, что элемент ведёт в секцию кода указанной DLL, поэтому это элемент IAT, единственный для данной DLL. Далее видим разделение, а после него группу множества переходов, которые ни сгруппированы так, чтобы указывать на последовательные адреса, ни сами эти адреса не указывают на какую-либо DLL.

![](.gitbook/img/36/20.png)

Если отметим какой-нибудь из них и сделаем FIND REFERENCES:

![](.gitbook/img/36/21.png)

![](.gitbook/img/36/22.png)

Никаких результатов, приведших бы нас к API-функциям, поэтому можно прийти к выводу, что ниже мы также не встретим элементов, ссылающихся на API-функции, то есть концом IAT является:

КОНЕЦ: 460F28

![](.gitbook/img/36/23.png)

Теперь проверим, откуда начинается IAT-схема.

![](.gitbook/img/36/24.png)

Идём вверх и видим, что схема повторяется, пока не доходим до сюда. Лазурным отмечены разделения, группа, отмеченная жёлтым, опознаётся как ведущая в одну и ту же DLL, далее есть одно разделение, а затем элемент, ведущий в 80000008. Так как не знаем, соответствует ли он какой-либо DLL, то проверяем это с помощью FIND REFERENCES.

![](.gitbook/img/36/25.png)

Никаких результатов ни для этого элемента, ни для идущих перед ним, так что можем быть уверены, что первым элементом является 460818.

![](.gitbook/img/36/26.png)

Теперь у нас есть начало и конец IAT. Вычисляем размер:

НАЧАЛО – КОНЕЦ = 460F28 – 460818

![](.gitbook/img/36/27.png)

То есть размер равен 710.

Данные для IMP REC (от OEP и НАЧАЛА надо отнять базу образа):

```
OEP = 271B0
НАЧАЛО или RVA = 60818
РАЗМЕР = 710
```

Хорошо, теперь сделаем дамп с помощью OllyDump [\[ссылка\]](.gitbook/assets/files/35/OllyDump%20v3.00.110.7z).

![](.gitbook/img/36/28.png)

![](.gitbook/img/36/29.png)

Убираем галочку с Rebuild Import и дампим.

![](.gitbook/img/36/30.png)

Далее открываем IMP REC [\[ссылка\]](.gitbook/assets/files/34/ImportReconstructor16f.7z) без закрытия OllyDbg, в котором загружен исходный файл, остановленный на OEP.

![](.gitbook/img/36/31.png)

Ищем процесс в выпадающем меню и устанавливаем найденные значения.

![](.gitbook/img/36/32.png)

И нажимаем GET IMPORTS.

![](.gitbook/img/36/33.png)

Видим, что упаковщик не делает ничего особенного, чтобы затруднить нам работу здесь, все DLL правильны, так что нажимаем FIX DUMP и ищем дамп для починки.

![](.gitbook/img/36/34.png)

Починенный файл сохраняется под именем unpacked\_.exe, смотрим, работает ли он.

![](.gitbook/img/36/35.png)

Работает прекрасно, то есть не используются антидамповые приёмы, которые, как правило, можно встретить в более продвинутых упаковщиках.

Следующая жертва – это telock 0.98 [\[ссылка\]](.gitbook/assets/files/32/UnPackMe_tElock0.98.7z), которая послужит нам для того, чтобы открыть тему о переадресовочных элементах IAT.

![](.gitbook/img/36/36.png)

Пробуем метод PUSHAD, трассируем немного, чтобы понять, есть ли здесь какой-нибудь PUSHAD.

![](.gitbook/img/36/37.png)

Проходим его с помощью F7, затем ESP-FOLLOW IN DUMP.

![](.gitbook/img/36/38.png)

![](.gitbook/img/36/39.png)

Убираем анализ, чтобы посмотреть код.

![](.gitbook/img/36/40.png)

Видим, что метод PUSHAD не работает, а также есть защита от точек аппаратного останова, потому что при их использовании возникнет ошибка, так что убираем их.

![](.gitbook/img/36/41.png)

![](.gitbook/img/36/42.png)

И перезапускаем OllyDbg.

Так, этот метод не сработал, пробуем основанный на исключениях. Очищаем LOG и запускаем программу, чтобы отобразились случившиеся из них.

![](.gitbook/img/36/43.png)

Убираем галочки с исключений и перезапускаем, пытаясь отловить 4666а1, которая является последней в распаковщике.

![](.gitbook/img/36/44.png)

После прохода через несколько исключений с помощью SHIFT+F9, доходим до 4666f1.

![](.gitbook/img/36/45.png)

Теперь устанавливаем MEMORY BREAKPOINT ON ACCESS на первую секцию.

![](.gitbook/img/36/46.png)

Помним, что нужно нажать SHIFT+F9, чтобы миновать исключение, на котором остановились, без ошибок.

Ок, останавливаемся на паре исключений типа SINGLE STEP и прибываем в OEP в первой секции, где оказываемся на MEMORY BREAKPOINT ON EXECUTION.

![](.gitbook/img/36/47.png)

Значит, OEP равен 4271B0, такой же, как и у предыдущего примера CRUNCH, поэтому похоже, что это та же программа, упакованная другим пакером, но всё равно будем работать с ней, как если бы мы ничего не знали о ней.

Ок, в предыдущем примере мы знали, что этот видимый вызов ведёт на API-функцию GetVersion, но в данном случае это не так, здесь мы начинаем тему переадресовочных элементов, хе-хе.

Если сделаем

![](.gitbook/img/36/48.png)

для того, чтобы увидеть вызовы на другие секции и выяснить, есть ли вызовы каких-либо API-функций.

![](.gitbook/img/36/49.png)

Видим, что множество косвенных вызовов, которые вместо того, чтобы указывать на API-функции, ведут на моей машине в секцию 9fxxxx. Очевидно, что на других машинах эти адреса могут меняться и иметь другие значения.

Если посмотрим, что в этом списке ниже:

![](.gitbook/img/36/50.png)

Видим, что есть кое-какие прямые вызовы API-функций, отмеченные лазурным цветом, очевидно с помощью косвенного JMP (что-то он меня запутал – прим.пер.). Идёмте посмотрим некоторые из этих вызовов.

![](.gitbook/img/36/51.png)

Тут у нас один – это CALL 435CDE, который точно выведет нас на косвенные переходы к API-функциям, отмечаем его, нажимаем правую кнопку мыши и выбираем FOLLOW.

![](.gitbook/img/36/52.png)

Видим косвенные переходы на API-функции, поэтому знаем, что берутся значения из IAT, т.е. 460ED4 – это элемент IAT. Идём в DUMP, чтобы посмотреть на него.

![](.gitbook/img/36/53.png)

Видим, что заключительная часть IAT корректна и совпадает с той, что в примере CRUNCH. Конец IAT здесь также 460F28. Здесь конец легко определить, так как потом идут одни нули. Теперь идём вниз.

![](.gitbook/img/36/54.png)

Видим, что следующая группа конфликтует, элемент, непосредственно стоящий до разделения, соответствует 76B1A8F7. Если отметим его, нажмём правую кнопку мыши и выберем FIND REFERENCES:

![](.gitbook/img/36/55.png)

Видим, что он относится к API-функции PlaySoundA из WINMM.dll, больше других значений, ведущих в DLL не встречается, однако если поищем ссылки:

![](.gitbook/img/36/56.png)

Видим, что раз существуют ссылки, то вот в чём дело, когда мы идём вверх и вниз от начала IAT, то если, например, искали до начала, то не нашли никаких ссылок, программа при этом переходит на API-функции из DLL с помощью IAT, за пределами её мы также не нашли никаких ссылок, теперь мы видим, что это возможные элементы IAT, так как нашли ссылки, которые берут значения из них в коде, но вместо перехода в DLL, происходит переход на секцию, которая в моём случае является Axxxxx (а на другой машине может быть другой), что это такое?

Это как раз то, что называется переадресовочными элементами. При запуске упаковщик перезаписывает некоторые элементы IAT значениями, указывающими на его собственные процедуры. В случае с предыдущим изображением:

```
004038A6 CALL DWORD PTR DS:[460E48]

Comment=DS:[00460E48]=00A00B61
```

Вместо сохранения правильного на моей машине адреса API-функции распаковщик заменяет его адресом собственного секции, им же созданной, во время выполнения, и там находится процедура, которая в результате выполняет правильную API-функцию.

Чтобы лучше понять это, давайте посмотрим на вхождение API-функции GetVersion, которое встречается под OEP.

![](.gitbook/img/36/57.png)

На самом деле мы не знаем, что оно ведёт на GetVersion, мы знаем только, что в предыдущем примере, где была запакована такая же программа с помощью CRUNCH. Здесь находится косвенный CALL, доходим до него с помощью F7 и входим внутрь, чтобы посмотреть, что там находится.

![](.gitbook/img/36/58.png)

Видим, что откуда-то берутся значения, откуда мы точно не знаем, но возможно, что из элементов IAT, так как ниже видим правильные вхождения вызовов API-функций.

![](.gitbook/img/36/59.png)

Поэтому программа при запуске CALL идёт сюда, на моей машине это адрес 9F06F7, на ваших оно может быть другим.

Это адрес не принадлежит какой-либо секции программы.

![](.gitbook/img/36/60.png)

Здесь видим секции программы (выделены лазурным цветом), а ниже секцию без имени, где находится процедура, куда переходит программа.

Если перезапустим программу, то увидим, что эта секция в начале не существует.

![](.gitbook/img/36/61.png)

Поэтому понятно, что она создаётся программой во время распаковки. Теперь, можем ли мы найти момент, когда создаётся данная секция?

Можем поставить BP на API-функцию VirtualAlloc, которая используется для создания виртуальных секций.

![](.gitbook/img/36/62.png)

Теперь делаем RUN и, если все галочки в исключениях были отмечены, то увидим, что программа завершилась и более не выполняется. Очевидно, что она обнаружила установленный BP, попробуем поставить его на RET из вышеуказанной функции.

![](.gitbook/img/36/63.png)

Теперь делаем RUN.

![](.gitbook/img/36/64.png)

Когда выполнение останавливается на возвращении из API-функции, в EAX содержится адрес созданной секции.

![](.gitbook/img/36/65.png)

Созданные секции можно посмотреть в карте памяти.

![](.gitbook/img/36/66.png)

Нам может помочь то, что когда программа создаёт секции для собственного использования, они помечаются как PRIV (т.е. private или собственная), это означает, что этих секций не было в начале до распаковки, так что точно знаем, что они были созданы распаковщиком.

Поэтому убираем BP и прибываем в OEP, как и раньше убрав галочки с исключений, и дойдя до последнего, устанавливая BPM ON ACCESS на первую секцию. Последнее исключение проходим с помощью SHIFT+F9.

![](.gitbook/img/36/67.png)

Теперь снова прибываем в OEP и посмотрим в карту памяти:

![](.gitbook/img/36/68.png)

Видим созданные секции, которые будут использоваться программой, отмеченные как PRIV, и сюда будут перенаправляться косвенные вызовы. К ним мы и возвратимся, используя F7.

![](.gitbook/img/36/69.png)

Трассируем, чтобы узнать, куда приведёт данная процедура.

![](.gitbook/img/36/70.png)

Видим, что дошли до PUSH, который помещает адрес GetVersion в стек, а затем переходит на API-функцию, дойдя до RET, поэтому данная процедура служит посредником для вызова API-функции GetVersion.

То есть распаковщик заменяет вхождения API-функции GetVersion адресом, указывающим на собственную секцию, то есть созданную им самим, и если оттрасируем до конца, то дойдём до места, где вызывается правильный API-адрес.

Это и есть переадресовочный элемент.

Поэтому когда проверяем начало и конец IAT, не только нужно проверять, что элемент ведёт в DLL, но так же нужно учитывать существование элементов IAT, которые содержат ссылки и ведут нас на собственный код упаковщика, служащий посредником, вызывающим собственно API-функцию.

Поэтому возвращаемся в IAT, который мы уже смотрели, чтобы найти НАЧАЛО и КОНЕЦ.

![](.gitbook/img/36/71.png)

Все элементы, которые ведут в секцию 0Axxxxxx (на моей машине) являются переадресовочными элементами. Идём в код, созданный распаковщиком, который не существует при запуске программы с OEP, поэтому идём ниже, чтобы увидеть, найдётся ли НАЧАЛО IAT.

![](.gitbook/img/36/72.png)

Видим, что далее есть несколько элементов, которые ведут в DLL, а затем выше них элементы, ведущие в 9Fxxxx – другую секцию, созданную распаковщиком.

![](.gitbook/img/36/73.png)

Видим, что указанные элементы содержат ссылки, поэтому это элементы IAT, спускаемся дальше.

![](.gitbook/img/36/74.png)

Далее видим элементы, которые на моей машине ведут в A1xxxx – это ещё одна секция, созданная упаковщиком.

![](.gitbook/img/36/75.png)

Также, если поищем, то найдём в них ссылки.

![](.gitbook/img/36/76.png)

Значит, это элементы IAT, и продолжаем спускаться дальше, видим, что оказались здесь:

![](.gitbook/img/36/77.png)

Где есть элементы, ведущие в какую-то DLL, затем разделения, а выше никакие элементы не содержат ссылки.

![](.gitbook/img/36/78.png)

Как и в случае с CRUNCH’ем началом IAT является 460818, размер 710, и OEP равен 4271B0. Отнимаем от него базу образа.

OEP = 271B0

НАЧАЛО или RVA = 60818

РАЗМЕР = 710

Поэтому открываем IMP REC, не закрывая OllyDbg.

![](.gitbook/img/36/79.png)

И устанавливаем найденные значения.

![](.gitbook/img/36/80.png)

Теперь нажимаем GET IMPORTS.

![](.gitbook/img/36/81.png)

Как видим, IMP REC обнаружил, что есть переадресовочные элементы и пометил их как NO, посмотрим их, нажав SHOW INVALIDS.

![](.gitbook/img/36/82.png)

IMP REC показал нам элементы IAT, которые не указывают на какую-либо API-функцию и которые ведут в секции, созданные упаковщиком.

Конечно, мы не будем трассировать все эти неправильные элементы вручную, есть несколько методов, чтобы их починить. IMP REC предоставляет несколько возможностей, также есть другие "ручные" методы, но без трассировки, хе-хе.

Все эти методы мы рассмотрим в 37 главе, поэтому вы должны хорошо уяснить рассмотренную тему о переадресовочных элементах, так как в следующей главе будут изложены несколько методов, чтобы их починить. Пока что мы не можем починить дамп, так как IMP REC’у требуется, чтобы все элементы были отмечены как YES, то есть указывали на API-функции из DLL, и не было никаких переадресовочных элементов, так что эту проблему на надо будет решить.

\[C\] Рикардо Нарваха, пер. Aquila
