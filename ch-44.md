# Глава 44 - Распаковка ACProtect v1.09 (Борьба с "антидампом")

Ок, продолжаем как обычно. Мы уже нашли украденные байты, и у нас теперь есть скрипты [\[ссылка\]](.gitbook/assets/files/44/scripts%20(44).7z) для того, чтобы легко попасть в OEP и чтобы починить IAT, так что осталось сделать дамп.

![](.gitbook/img/44/1.png)

Открываем программу [\[ссылка\]](.gitbook/assets/files/42/UnPackMe_ACProtect1.09g.f.7z) в OllyDbg и устанавливаем два BP, необходимых для работы скриптов, и стираем BPX, которые могли остаться от прошлого раза.

![](.gitbook/img/44/2.png)

Теперь используем скрипт для OEP и тут же попадаем в него.

![](.gitbook/img/44/3.png)

![](.gitbook/img/44/4.png)

Отвечаем, что нет и находимся в OEP.

![](.gitbook/img/44/5.png)

Теперь делаем дамп.

![](.gitbook/img/44/6.png)

![](.gitbook/img/44/7.png)

Снимаем галку и сохраняем как dumped.exe или другое имя, которое мы хотим. Теперь перезапускаем OllyDbg и используем скрипт для того, чтобы работать с починенной таблицей.

![](.gitbook/img/44/8.png)

Здесь уже всё работает, так что открываем IMPORT RECONSTRUCTOR [\[ссылка\]](.gitbook/assets/files/34/ImportReconstructor16f.7z) и ищем нужный нам процесс в списке процессов в выпадающем меню.

Теперь ищем данные OEP, RVA и РАЗМЕР IAT, как мы это делали в прошлой части.

OEP=**271b5**

НАЧАЛО=**60818**

РАЗМЕР= 460f28-460818= **710**

Видим, что все API-функции правильны кроме одной. Я её пропустил?

Можем посмотреть, что случится, если бы эта ошибка не была показана. Рестартуем OllyDbg и устанавливаем на этот элемент MEMORY BREAKPOINT ON WRITE.

![](.gitbook/img/44/9.png)

И делаем RUN, чтобы оказаться в месте, где сохраняется плохое значение.

![](.gitbook/img/44/10.png)

Здесь видим, что будет сохраняться значение и в ESP-0C нет никакой API-функции.

![](.gitbook/img/44/11.png)

Видим, что скрипт изменил его на значение, которое в данном случае равно 46E5CB, так что видим значение, которое сохраняется в IAT без использования скрипта. Нажимаем F7.

![](.gitbook/img/44/12.png)

Значение, сохраняющееся без использования скрипта, будет плохим, так что смотрим, куда оно ведёт. Идём в 46BD5B.

![](.gitbook/img/44/13.png)

Хорошо, как видели раньше, выполняется PUSH константа, и над ней совершается XOR с другой константой, а результатом этой операции становится адрес API-функции. Считаем.

942c0892 xor 946aed59

Если нет желания использовать калькулятор, может использовать то, что OllyDbg выполнит сама эти строки и получит результат, хе-хе.

![](.gitbook/img/44/14.png)

![](.gitbook/img/44/15.png)

Видим, что результатом XOR является 46E5CB – это значение, которое скрипт поместит в элемент, поэтому скрипт не ошибается. Дело в том, что этот элемент особенный, так что рестартуем и прибываем в OEP, что посмотреть, найдём ли то, к чему динамически относится API-функция, то есть, откуда она запускается.

![](.gitbook/img/44/16.png)

Тут оказываемся в OEP с помощью соответствующего скрипта и устанавливаем BPM ON ACCESS на элементе IAT, относительно которого хотим узнать, к какой API-функции он ведёт, для чего останавливаемся, чтобы получить к нему доступ.

![](.gitbook/img/44/17.png)

Останавливаемся, трассируем.

![](.gitbook/img/44/18.png)

Конечно, доходим до RET и отсюда прыгаем:

![](.gitbook/img/44/19.png)

Посмотрим, ведёт ли это к какой-нибудь API-функции. Начинаем трассировать с помощью F7 и видим, что это ведёт в большой кусок кода, так что применяем метод pushad. Вот эта инструкция в начале, и останавливаемся на POPAD, до куда нужно оттрасировать некоторое количество строк.

![](.gitbook/img/44/20.png)

И видим, что API-функция, с которой у нас проблемы – это MessageBoxA.

Другой, более быстрый метод – это сделать RUN TRACE с условием, что необходимо остановиться, когда EIP станет, например, больше 500000, то есть когда произойдёт выход из секции в API-функцию. Смотрим:

![](.gitbook/img/44/21.png)

Здесь останавливаемся, когда EIP выходит за пределы 0-500000. Пробуем, сработает ли.

![](.gitbook/img/44/22.png)

![](.gitbook/img/44/23.png)

Останавливаемся прямо на API-функции MessageBoxA. Последняя проверка, чтобы убедиться, что это правильная API-функция и не фальшивка, заключается в том, чтобы возвратиться в исполняемый файл в то место, где находится продолжение вызова, из которого отправились. Это можно узнать в первой строке стека. Смотрим:

![](.gitbook/img/44/24.png)

Адрес возврата – это 40E51B. Если пойдём туда:

![](.gitbook/img/44/25.png)

Возвращаемся прямо на следующую строку вызванного call’а, так что у нас уже есть все данные. Перезапускаем процесс с помощью скрипта для IAT и устанавливаем данные как в прошлый раз в IMP REC.

![](.gitbook/img/44/26.png)

Делаем двойной щелчок по неправильному элементу и меняем его на MessageBoxA.

![](.gitbook/img/44/27.png)

Теперь, если всё правильно, починим дамп с помощью FIX DUMP. Ищем файл дампа.

![](.gitbook/img/44/28.png)

И сохраняем его как dumped\_.exe. Нам осталось исправить OEP на предмет украденных байтов, так что открываем файл в OllyDbg.

![](.gitbook/img/44/29.png)

Нам нужно скопировать украденные байты и поменять OEP.

```assembly
00485AF3 Main     PUSH EBP
00485AF4 Main     MOV EBP,ESP                               ; EBP=0012FFC0
00485AF6 Main     PUSH -1
```

Вот украденные байты, которые мы можем ввести с помощью функции "Assemble".

![](.gitbook/img/44/30.png)

![](.gitbook/img/44/31.png)

Видим введённые байты, которых ровно пять, так что теперь считаем: 4271b5 (фальшивая OEP) минус пять байт дают нам правильный OEP, то есть 4271b0.

![](.gitbook/img/44/32.png)

Теперь, если сохраним изменения с помощью COPY TO EXECUTABLE – SAVE FILE, мне останется поменять OEP. Перезапускаем и идём в заголовок дампа с помощью GOTO EXPRESSION 400000.

![](.gitbook/img/44/33.png)

Переходим в режим SPECIAL-PE HEADER, ищем значение ADDRESS OF ENTRY POINT, меняем его и сохраняем изменения.

![](.gitbook/img/44/34.png)

![](.gitbook/img/44/35.png)

Ок, если запустим файл после починки, то будет показана ошибка. Снимаем все галочки с исключений и смотрим, какой ещё трюк был применён против нас.

![](.gitbook/img/44/36.png)

Видим в LOG’е, что произошла ошибка, смотрим CALL STACK, то есть нажимаем кнопку с буквой "K", показывающую последние исполненные call’ы (можем также посмотреть в стеке RETURN TO…).

![](.gitbook/img/44/37.png)

Последний CALL был выполнен из 429806, идём туда.

![](.gitbook/img/44/38.png)

![](.gitbook/img/44/39.png)

Продолжаем с помощью FOLLOW, чтобы посмотреть куда идёт CALL.

![](.gitbook/img/44/40.png)

Хе-хе, таблица косвенных переходов, которая приводит к появлению ошибки, так как секции памяти, в которой находится 177658 и следующие адреса, нет в дампе и создаётся упаковщиком во время распаковки оригинального кода, так что нам осталось решить эту проблему, которая является одним из многих противоотладочных методов.

Запускаем оригинальный файл в другом OllyDbg и доходим до OEP с помощью скрипта, стирая старые HBP и устанавливая два необходимых BP.

![](.gitbook/img/44/41.png)

Доходим до сюда, смотрим область этих косвенных переходов.

![](.gitbook/img/44/42.png)

Если пойдём в DUMP, то там табличка, откуда берутся значения для перехода.

![](.gitbook/img/44/43.png)

Ок, есть много способов решить эту проблему. Классический – это сделать инъекцию в то же место, где создаётся секция и скопировать все байты в вышеуказанную секцию, откуда всё сохраняется, а затем перейти на OEP, починив всё. Смотрим, сможем ли найти альтернативный метод, который были бы гораздо проще, так как описанный метод мы будем использовать часто в других упаковщиках.

Ищем первый переход в 46c0f5.

![](.gitbook/img/44/44.png)

Он занимает 6 байт – инструкция JMP, ведущая в 178250, где также происходит выполнение 6 байт и возврат.

![](.gitbook/img/44/45.png)

Идея заключается в том, чтобы заменить 6 байтов косвенного перехода на 6 байтов, которые действительно что-то делают.

![](.gitbook/img/44/46.png)

Отмечаем три строки и делаем BINARY COPY.

Возвращаемся к переходу и делаем BINARY PASTE.

![](.gitbook/img/44/47.png)

![](.gitbook/img/44/48.png)

Должно работать. Эти косвенные переходы вызываются call’ами из программы, так что выполняется шесть байт, и при срабатывании RETN будет происходить возврат туда, откуда произошёл вызов.

Поскольку переходы идут друг за другом и размер выполняемых команд всегда равен шести байтам, то мы можем скопировать сюда всю секцию, чтобы заменить переходы собственно тем, что должно выполняться.

![](.gitbook/img/44/49.png)

Байты начинают выполняться с 178256 – это первый элемент таблицы, а последний заканчивается в 1799ba.

![](.gitbook/img/44/50.png)

Так что копируем с помощью BINARY COPY всю область с нужными нам байтами и заменяем переходы с помощью BYNARY PASTE.

![](.gitbook/img/44/51.png)

Видим, что получилось, также видим, что некоторые переходы в конце ведут к частям, у которых нет RET.

![](.gitbook/img/44/52.png)

Я предположил, что эти переходы не используются, так что, по идее, проблем возникнуть не должно. Ок, починили секцию. Теперь может сделать BINARY COPY всей секции и скопировать её в файл дампа с помощью BYNARY PASTE.

![](.gitbook/img/44/53.png)

Теперь сохраняем изменения в дамп с помощью COPY TO EXECUTABLE и так далее.

![](.gitbook/img/44/54.png)

Чтобы сохранить их и нам не было сказано, что не можем этого сделать, делаем так: от конца секции поднимается до последней строки, где есть данные.

![](.gitbook/img/44/55.png)

Отмечаем отсюда и до начала секции вверх и сохраняем изменения. Перезапускаем и пробуем.

![](.gitbook/img/44/56.png)

Работает превосходно. Мы победили украденные байты, переадресовочную IAT, антидампы, и защиту против HBP.

\[C\] Рикардо Нарваха, пер. Aquila
